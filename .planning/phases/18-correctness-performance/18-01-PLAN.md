---
phase: 18-correctness-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jamma/cli.py
  - tests/test_cli.py
  - src/jamma/lmm/runner_jax.py
  - src/jamma/lmm/runner_streaming.py
autonomous: true

must_haves:
  truths:
    - "Running `jamma kinship -gk 2` raises NotImplementedError with a clear message"
    - "U.T is computed once as a contiguous array and reused across all chunks in both runners"
    - "All existing tests pass with identical statistical output"
  artifacts:
    - path: "src/jamma/cli.py"
      provides: "NotImplementedError for gk mode 2"
      contains: "raise NotImplementedError"
    - path: "tests/test_cli.py"
      provides: "Test for gk mode 2 rejection"
      contains: "test_cli_gk_mode_2_not_implemented"
    - path: "src/jamma/lmm/runner_jax.py"
      provides: "Cached UT in batch runner"
      contains: "np.ascontiguousarray(U.T)"
    - path: "src/jamma/lmm/runner_streaming.py"
      provides: "Cached UT in streaming runner"
      contains: "np.ascontiguousarray(U.T)"
  key_links:
    - from: "src/jamma/cli.py"
      to: "NotImplementedError"
      via: "mode == 2 guard in gk_command"
      pattern: "if mode == 2.*raise NotImplementedError"
    - from: "src/jamma/lmm/runner_jax.py"
      to: "_prepare_chunk closure"
      via: "UT captured from outer scope"
      pattern: "UT @ geno_chunk"
    - from: "src/jamma/lmm/runner_streaming.py"
      to: "_prepare_jax_chunk closure"
      via: "UT captured from outer scope"
      pattern: "UT @ geno_jax_chunk"
---

<objective>
Close the kinship mode 2 correctness gap and cache the eigenvector transpose for both LMM runners.

Purpose: CORR-01 prevents silent incorrect behavior when users request unimplemented kinship mode 2. PERF-01 eliminates redundant transpose computation on every chunk by pre-computing a contiguous UT array once.
Output: Fixed CLI guard, new test, and optimized UT caching in both runner_jax.py and runner_streaming.py.
</objective>

<execution_context>
@/Users/mdenyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mdenyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-correctness-performance/18-RESEARCH.md
@src/jamma/cli.py
@src/jamma/lmm/runner_jax.py
@src/jamma/lmm/runner_streaming.py
@tests/test_cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: CORR-01 - Raise NotImplementedError for kinship mode 2</name>
  <files>src/jamma/cli.py, tests/test_cli.py</files>
  <action>
In `src/jamma/cli.py`, replace lines 147-152 (the mode 2 warning+fallback) with a hard error:

```python
# Replace this block:
#   if mode == 2:
#       typer.echo(
#           "Warning: Mode 2 (standardized) not yet implemented, "
#           "using mode 1 (centered)"
#       )

# With:
if mode == 2:
    raise NotImplementedError(
        "Kinship mode 2 (standardized) is not yet implemented. "
        "Use -gk 1 for centered relatedness matrix."
    )
```

Also remove the misleading `mode {mode}` from the subsequent log message at line 155. Since mode 2 now raises before reaching this line, the log always refers to mode 1. Change:
  `f"Computing centered kinship matrix (mode {mode})..."`
to:
  `"Computing centered kinship matrix..."`

In `tests/test_cli.py`, add a new test after the existing `test_cli_gk_*` tests:

```python
def test_cli_gk_mode_2_not_implemented(tmp_path: Path):
    """Test that -gk 2 raises NotImplementedError instead of silently falling back."""
    outdir = tmp_path / "output"
    result = runner.invoke(
        app, ["-outdir", str(outdir), "gk", "-bfile", str(EXAMPLE_BFILE), "-gk", "2"]
    )
    assert result.exit_code == 1
    assert isinstance(result.exception, NotImplementedError)
    assert "mode 2" in str(result.exception).lower()
    assert "not yet implemented" in str(result.exception).lower()
```

The test uses Typer's CliRunner which captures unhandled exceptions in `result.exception` and sets `exit_code` to 1.
  </action>
  <verify>
Run: `uv run pytest tests/test_cli.py -x -k "gk" -v`
Expected: All gk tests pass, including the new `test_cli_gk_mode_2_not_implemented`.
  </verify>
  <done>
`jamma kinship -gk 2` raises NotImplementedError with message containing "not yet implemented" and "Use -gk 1". No silent fallback to mode 1 occurs. Existing gk tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: PERF-01 - Cache contiguous U.T in both runners</name>
  <files>src/jamma/lmm/runner_jax.py, src/jamma/lmm/runner_streaming.py</files>
  <action>
**In `src/jamma/lmm/runner_jax.py`:**

After the eigendecomposition call at line 170-172, add:
```python
UT = np.ascontiguousarray(U.T)  # Cache contiguous transpose for BLAS matmuls
```

Replace line 174 (`UtW = U.T @ W`) with:
```python
UtW = UT @ W
```

Replace line 175 (`Uty = U.T @ phenotypes`) with:
```python
Uty = UT @ phenotypes
```

In the `_prepare_chunk` closure (line 245), replace:
```python
UtG_chunk = np.ascontiguousarray(U.T @ geno_chunk)
```
with:
```python
UtG_chunk = np.ascontiguousarray(UT @ geno_chunk)
```

The closure captures `UT` from the enclosing scope (same pattern as it currently captures `U`).

**In `src/jamma/lmm/runner_streaming.py`:**

After the eigendecomposition call at line 262-264, add:
```python
UT = np.ascontiguousarray(U.T)  # Cache contiguous transpose for BLAS matmuls
```

Replace line 269 (`UtW = U.T @ W`) with:
```python
UtW = UT @ W
```

Replace line 270 (`Uty = U.T @ phenotypes`) with:
```python
Uty = UT @ phenotypes
```

In the `_prepare_jax_chunk` nested function (line 348), replace:
```python
UtG_chunk = np.ascontiguousarray(U.T @ geno_jax_chunk)
```
with:
```python
UtG_chunk = np.ascontiguousarray(UT @ geno_jax_chunk)
```

Note: `_prepare_jax_chunk` is re-defined inside the file-chunk loop at line 332. It captures variables from the enclosing scope. The `UT` variable is defined at function scope (above the loop), so it will be captured correctly.

Do NOT change any function signatures, return types, or public API. This is a pure internal optimization.
  </action>
  <verify>
Run the full test suite: `uv run pytest tests/ -x`
Expected: All tests pass with no numerical changes.

Additionally verify contiguity with a quick grep:
`grep -n "U\.T" src/jamma/lmm/runner_jax.py src/jamma/lmm/runner_streaming.py`
Expected: No remaining `U.T` references (all replaced by `UT`).
  </verify>
  <done>
Both `runner_jax.py` and `runner_streaming.py` compute `UT = np.ascontiguousarray(U.T)` exactly once after eigendecomposition. All `U.T` usages in both files are replaced with `UT`. No `U.T` references remain in either runner. All existing tests pass identically.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_cli.py -x -k "gk" -v` -- all gk CLI tests pass including new mode 2 test
2. `uv run pytest tests/ -x` -- full suite passes, no numerical regressions
3. `grep -n "U\.T" src/jamma/lmm/runner_jax.py src/jamma/lmm/runner_streaming.py` returns no matches
4. `grep -n "NotImplementedError" src/jamma/cli.py` shows the mode 2 guard
</verification>

<success_criteria>
- `jamma kinship -gk 2` raises NotImplementedError (not a silent fallback)
- Zero `U.T` references remain in either runner file
- `UT = np.ascontiguousarray(U.T)` appears exactly once in each runner
- Full test suite passes with zero numerical changes
</success_criteria>

<output>
After completion, create `.planning/phases/18-correctness-performance/18-01-SUMMARY.md`
</output>
