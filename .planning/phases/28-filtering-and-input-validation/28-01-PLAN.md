---
phase: 28-filtering-and-input-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jamma/io/snp_list.py
  - src/jamma/io/__init__.py
  - src/jamma/core/snp_filter.py
  - src/jamma/lmm/runner_streaming.py
  - src/jamma/lmm/loco.py
  - src/jamma/kinship/compute.py
  - tests/test_snp_filter.py
  - tests/test_snp_list.py
autonomous: true

must_haves:
  truths:
    - "SNP list file parsed into set of RS IDs with one ID per line"
    - "SNP RS IDs resolved to column indices via BIM intersection"
    - "HWE chi-squared p-values computed from genotype counts (AA, AB, BB)"
    - "SNP list mask ANDed into existing snp_mask before pass-2 association"
    - "HWE filter mask ANDed into existing snp_mask before pass-2 association"
    - "-ksnps restricts kinship SNPs independently of association SNP list"
    - "Genotype counts accumulated during pass-1 streaming (no extra disk pass)"
  artifacts:
    - path: "src/jamma/io/snp_list.py"
      provides: "read_snp_list_file and resolve_snp_list_to_indices functions"
      contains: "read_snp_list_file"
    - path: "src/jamma/core/snp_filter.py"
      provides: "compute_hwe_pvalues function using JAX chi2.sf"
      contains: "compute_hwe_pvalues"
    - path: "src/jamma/lmm/runner_streaming.py"
      provides: "snps_indices and hwe_threshold parameters wired into pass-1 and filter composition"
      contains: "hwe_threshold"
    - path: "src/jamma/lmm/loco.py"
      provides: "snps_indices parameter for per-chromosome SNP restriction"
      contains: "snps_indices"
    - path: "src/jamma/kinship/compute.py"
      provides: "ksnps_indices parameter for kinship SNP restriction"
      contains: "ksnps_indices"
  key_links:
    - from: "src/jamma/core/snp_filter.py"
      to: "src/jamma/lmm/runner_streaming.py"
      via: "compute_hwe_pvalues called after pass-1 genotype counts"
      pattern: "compute_hwe_pvalues"
    - from: "src/jamma/io/snp_list.py"
      to: "src/jamma/lmm/runner_streaming.py"
      via: "snps_indices passed as parameter for snp_mask composition"
      pattern: "snps_indices"
    - from: "src/jamma/io/snp_list.py"
      to: "src/jamma/kinship/compute.py"
      via: "ksnps_indices passed for kinship SNP restriction"
      pattern: "ksnps_indices"
---

<objective>
Implement SNP list filtering, HWE QC computation, and integrate both into the
streaming LMM runners and kinship computation (SNP-01, SNP-02, SNP-03, QC-01, QC-02).

Purpose: Researchers need to restrict which SNPs enter association testing (-snps),
which enter kinship computation (-ksnps), and exclude SNPs failing Hardy-Weinberg
equilibrium (-hwe). These filters compose with existing MAF/missingness filters
via boolean mask AND.

Output: SNP list I/O module, HWE computation in snp_filter, integration into
runner_streaming, loco, and kinship/compute with unit tests.
</objective>

<execution_context>
@/Users/mdenyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mdenyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/28-filtering-and-input-validation/28-RESEARCH.md

@src/jamma/io/snp_list.py
@src/jamma/io/__init__.py
@src/jamma/core/snp_filter.py
@src/jamma/lmm/runner_streaming.py
@src/jamma/lmm/loco.py
@src/jamma/kinship/compute.py
@src/jamma/io/plink.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SNP list I/O and HWE computation functions</name>
  <files>
    src/jamma/io/snp_list.py
    src/jamma/io/__init__.py
    src/jamma/core/snp_filter.py
    tests/test_snp_list.py
    tests/test_snp_filter.py
  </files>
  <action>
**Create `src/jamma/io/snp_list.py`** with two functions:

1. `read_snp_list_file(path: Path) -> set[str]`:
   - Read a text file with one RS ID per line (matching GEMMA's SNP list format).
   - Strip whitespace, skip empty lines. Use first whitespace-delimited token per
     line (matches GEMMA's strtok behavior for lines with extra columns).
   - Raise `FileNotFoundError` if file doesn't exist.
   - Raise `ValueError` if file is empty or contains no valid IDs.
   - Return a `set[str]` for O(1) membership testing.

2. `resolve_snp_list_to_indices(snp_ids: set[str], bim_sids: np.ndarray) -> np.ndarray`:
   - Build dict `{sid: index}` from bim_sids. For each snp_id in snp_ids, look up
     the index. Collect matches into a sorted int array.
   - Case-sensitive comparison (matching GEMMA).
   - Raise `ValueError` if zero SNPs match.
   - Log warning with found/requested counts when some SNPs are missing.
   - Return `np.array(indices, dtype=np.intp)`.

**Update `src/jamma/io/__init__.py`:**
   - Add imports for `read_snp_list_file` and `resolve_snp_list_to_indices`.
   - Add to `__all__`.

**Add HWE computation to `src/jamma/core/snp_filter.py`:**

3. `compute_hwe_pvalues(n_aa: np.ndarray, n_ab: np.ndarray, n_bb: np.ndarray) -> np.ndarray`:
   - Compute HWE chi-squared p-values vectorized over all SNPs.
   - n = n_aa + n_ab + n_bb (total valid genotypes per SNP).
   - p = (2*n_aa + n_ab) / (2*n), q = 1 - p.
   - Expected: e_aa = n*p^2, e_ab = 2*n*p*q, e_bb = n*q^2.
   - chi_sq = sum of (observed - expected)^2 / expected for each genotype class.
   - Use `np.errstate(invalid="ignore", divide="ignore")` for degenerate SNPs.
   - Replace NaN chi_sq with 0.0 (degenerate SNPs pass HWE by convention).
   - **Use `jax.scipy.stats.chi2.sf(chi_sq, df=1)`** for p-value computation.
     This avoids adding scipy as a runtime dependency (scipy is dev-only).
     Import jax at the function level: `import jax.scipy.stats as jax_stats`.
     Convert inputs to JAX arrays for chi2.sf, then back to numpy.
   - Return numpy array of p-values, one per SNP.
   - Docstring: Google-style, document the chi-squared approximation, note it
     differs from GEMMA's exact test (Wigginton 2005).

**Create `tests/test_snp_list.py`:**

4. Tests for SNP list I/O:
   - `test_read_snp_list_basic`: Write temp file with 3 RS IDs, verify set returned.
   - `test_read_snp_list_strips_whitespace`: Lines with leading/trailing whitespace.
   - `test_read_snp_list_skips_empty_lines`: File with blank lines interspersed.
   - `test_read_snp_list_first_token_only`: Lines with extra columns ("rs123 1 A T"),
     verify only "rs123" is extracted.
   - `test_read_snp_list_file_not_found`: Raises FileNotFoundError.
   - `test_read_snp_list_empty_file`: Raises ValueError.
   - `test_resolve_snp_list_to_indices`: 5 BIM sids, request 3, get sorted indices.
   - `test_resolve_snp_list_partial_match`: Request 5, only 3 found, warning logged.
   - `test_resolve_snp_list_zero_match`: None found, raises ValueError.
   - `test_resolve_snp_list_case_sensitive`: "RS001" vs "rs001" -- no match.

**Add HWE tests to `tests/test_snp_filter.py`** (create if it doesn't exist, or add
to existing test file for snp_filter):

5. Tests for HWE computation:
   - `test_hwe_perfect_equilibrium`: n_aa=25, n_ab=50, n_bb=25 (p=0.5).
     Expected chi_sq=0, p-value=1.0. Verify p >= 0.99.
   - `test_hwe_strong_deviation`: n_aa=90, n_ab=10, n_bb=0.
     Expected p-value near 0 (strong deviation). Verify p < 0.001.
   - `test_hwe_vectorized`: Pass arrays of 100 SNPs, verify output shape matches.
   - `test_hwe_degenerate_snp`: All same genotype (n_aa=100, n_ab=0, n_bb=0).
     Should return p=1.0 (or at least not NaN/error).
   - `test_hwe_known_value`: Use a textbook example with known chi-squared value.
     E.g., n_aa=735, n_ab=210, n_bb=55 (N=1000, p=0.84, q=0.16).
     Expected e_aa=705.6, e_ab=268.8, e_bb=25.6.
     chi_sq = (735-705.6)^2/705.6 + (210-268.8)^2/268.8 + (55-25.6)^2/25.6 = ~48.3.
     p-value should be essentially 0. Verify p < 1e-10.
  </action>
  <verify>
`uv run pytest tests/test_snp_list.py tests/test_snp_filter.py -x -v` -- all tests pass.
`uv run ruff check src/jamma/io/snp_list.py src/jamma/core/snp_filter.py` -- clean lint.
  </verify>
  <done>
SNP list file reading works with all edge cases (whitespace, empty lines, extra columns,
missing file, empty file). SNP ID resolution to indices works with partial matches,
zero matches, and case sensitivity. HWE chi-squared p-values computed correctly for
perfect equilibrium, strong deviation, degenerate, and textbook cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SNP list and HWE filters into streaming runners and kinship</name>
  <files>
    src/jamma/lmm/runner_streaming.py
    src/jamma/lmm/loco.py
    src/jamma/kinship/compute.py
    tests/test_snp_filter.py
  </files>
  <action>
**Update `src/jamma/lmm/runner_streaming.py` (`run_lmm_association_streaming`):**

1. Add parameters to function signature:
   - `snps_indices: np.ndarray | None = None` -- pre-resolved column indices for -snps
   - `hwe_threshold: float = 0.0` -- HWE p-value threshold (0 = disabled)

2. In PASS 1, add HWE genotype count accumulation (only when `hwe_threshold > 0`):
   - Before the stats_iterator loop, initialize:
     `all_n_aa = np.zeros(n_snps, dtype=np.int32)`
     `all_n_ab = np.zeros(n_snps, dtype=np.int32)`
     `all_n_bb = np.zeros(n_snps, dtype=np.int32)`
   - Inside the loop, after existing stats computation and after applying valid_mask:
     ```python
     if hwe_threshold > 0:
         valid_geno = ~np.isnan(chunk)
         all_n_aa[start:end] += np.sum((chunk == 0) & valid_geno, axis=0).astype(np.int32)
         all_n_ab[start:end] += np.sum((chunk == 1) & valid_geno, axis=0).astype(np.int32)
         all_n_bb[start:end] += np.sum((chunk == 2) & valid_geno, axis=0).astype(np.int32)
     ```
   - IMPORTANT: HWE counts must use the valid_mask-filtered chunk (after sample filtering),
     consistent with how existing stats (means, vars) are computed on `chunk[valid_mask, :]`.

3. After `compute_snp_filter_mask()` call, compose additional filters:
   ```python
   # Apply SNP list restriction (if -snps provided)
   if snps_indices is not None:
       snp_list_mask = np.zeros(n_snps, dtype=bool)
       snp_list_mask[snps_indices] = True
       snp_mask &= snp_list_mask
       logger.info(f"SNP list filter: restricting to {len(snps_indices)} requested SNPs")

   # Apply HWE filter (if -hwe threshold > 0)
   if hwe_threshold > 0:
       from jamma.core.snp_filter import compute_hwe_pvalues
       hwe_pvalues = compute_hwe_pvalues(all_n_aa, all_n_ab, all_n_bb)
       hwe_pass = hwe_pvalues >= hwe_threshold
       n_hwe_fail = int(np.sum(~hwe_pass & snp_mask))
       snp_mask &= hwe_pass
       logger.info(f"HWE filter: {n_hwe_fail} SNPs removed (p < {hwe_threshold})")
   ```
   Place this AFTER the existing `compute_snp_filter_mask()` call and BEFORE
   `snp_indices = np.where(snp_mask)[0]`.

**Update `src/jamma/lmm/loco.py` (`_run_lmm_for_chromosome`):**

4. Add `snps_indices: np.ndarray | None = None` parameter.
   After `compute_snp_filter_mask()`, add SNP list mask composition:
   ```python
   if snps_indices is not None:
       # Intersect with SNP list -- snps_indices are global, chr_snp_indices are global
       chr_snp_set = set(chr_snp_indices)
       local_snp_list_mask = np.array([
           idx in set(snps_indices) for idx in chr_snp_indices
       ], dtype=bool)
       snp_mask &= local_snp_list_mask
   ```
   Actually, more efficiently: create a boolean mask over local indices. The
   `chr_snp_indices` contains global column indices for this chromosome. The
   `snps_indices` contains global column indices from the SNP list. Intersect:
   ```python
   if snps_indices is not None:
       snps_set = set(snps_indices.tolist())
       local_snp_list_mask = np.array(
           [idx in snps_set for idx in chr_snp_indices], dtype=bool
       )
       snp_mask &= local_snp_list_mask
   ```

5. Update `run_lmm_loco()` to accept and pass through `snps_indices`:
   - Add `snps_indices: np.ndarray | None = None` parameter.
   - Pass `snps_indices=snps_indices` to `_run_lmm_for_chromosome()`.

**Update `src/jamma/kinship/compute.py`:**

6. Add `ksnps_indices: np.ndarray | None = None` parameter to
   `compute_kinship_streaming()` and `compute_loco_kinship_streaming()`.
   After `snp_mask` construction (after pass-1 stats), apply ksnps restriction:
   ```python
   if ksnps_indices is not None:
       ksnp_list_mask = np.zeros(n_snps, dtype=bool)
       ksnp_list_mask[ksnps_indices] = True
       snp_mask &= ksnp_list_mask
       logger.info(f"Kinship SNP list: restricting to {len(ksnps_indices)} requested SNPs")
   ```
   Place this BEFORE `n_filtered = int(np.sum(snp_mask))` and the subsequent
   zero-check. For `compute_loco_kinship_streaming`, place it after the existing
   snp_mask construction and before `n_filtered`.

**Add integration tests to `tests/test_snp_filter.py`:**

7. `test_snp_list_mask_composition`: Create a small genotype array (10 samples,
   20 SNPs). Compute snp_mask from `compute_snp_filter_mask`. Create
   `snps_indices = np.array([0, 5, 10, 15])`. AND the SNP list mask. Verify
   only the intersection of passing SNPs and the list survives.

8. `test_hwe_filter_composition`: Create genotypes where 2 SNPs are in perfect
   HWE (should pass) and 2 SNPs have extreme deviation (should fail with
   hwe_threshold=0.001). Verify the deviating SNPs are removed from snp_mask.

9. `test_snp_list_and_hwe_compose`: Both filters active simultaneously.
   Verify both are applied (AND semantics).
  </action>
  <verify>
`uv run pytest tests/test_snp_filter.py tests/test_snp_list.py -x -v` -- all tests pass.
`uv run pytest tests/ -x` -- full test suite passes (no regressions).
`uv run ruff check src/jamma/lmm/runner_streaming.py src/jamma/lmm/loco.py src/jamma/kinship/compute.py` -- clean lint.
  </verify>
  <done>
SNP list indices and HWE threshold parameters wired into runner_streaming,
loco, and kinship/compute. HWE genotype counts accumulated in pass-1 (no extra
disk pass). Both filters compose via boolean AND with existing MAF/missingness
filters. Integration tests verify composition semantics. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/ -x` -- full test suite passes
- `uv run ruff check .` -- clean lint
- SNP list functions handle all edge cases (empty, missing, partial match)
- HWE p-values correct for textbook examples
- SNP list + HWE + MAF/miss filters compose correctly via AND
- No extra disk pass for HWE (counts accumulated in pass-1)
- -ksnps parameter available on kinship streaming functions
- -snps parameter available on LMM streaming runner and LOCO
</verification>

<success_criteria>
- `read_snp_list_file()` parses GEMMA-format SNP list files correctly
- `resolve_snp_list_to_indices()` maps RS IDs to column indices via BIM
- `compute_hwe_pvalues()` returns correct chi-squared p-values
- `run_lmm_association_streaming()` accepts snps_indices and hwe_threshold
- `compute_kinship_streaming()` accepts ksnps_indices
- `compute_loco_kinship_streaming()` accepts ksnps_indices
- `run_lmm_loco()` accepts and passes through snps_indices
- All existing tests pass unchanged (backward compatible -- new params default to None/0)
</success_criteria>

<output>
After completion, create `.planning/phases/28-filtering-and-input-validation/28-01-SUMMARY.md`
</output>
