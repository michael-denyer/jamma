---
phase: 28-filtering-and-input-validation
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - src/jamma/pipeline.py
  - src/jamma/cli.py
  - src/jamma/gwas.py
  - src/jamma/io/plink.py
  - tests/test_pipeline.py
  - tests/test_cli.py
  - tests/test_plink_validation.py
autonomous: true

must_haves:
  truths:
    - "User can pass -snps flag to restrict association testing to a SNP list file"
    - "User can pass -ksnps flag to restrict kinship computation to a SNP list file"
    - "User can pass -hwe flag to exclude SNPs failing HWE chi-squared test"
    - "PLINK dimension mismatch (.bed size vs .fam/.bim counts) produces clear error"
    - "Unexpected genotype values outside {0, 1, 2, NaN} produce summary warning"
    - "gwas() Python API accepts snps_file, ksnps_file, and hwe parameters"
    - "All new flags have sensible defaults (None/0) preserving backward compatibility"
  artifacts:
    - path: "src/jamma/cli.py"
      provides: "-snps, -ksnps, -hwe flags on lmm command; -ksnps on gk command"
      contains: "-snps"
    - path: "src/jamma/gwas.py"
      provides: "snps_file, ksnps_file, hwe parameters on gwas() function"
      contains: "snps_file"
    - path: "src/jamma/pipeline.py"
      provides: "PipelineConfig with snps_file, ksnps_file, hwe_threshold; PipelineRunner resolves SNP lists and passes through"
      contains: "snps_file"
    - path: "src/jamma/io/plink.py"
      provides: "validate_plink_dimensions function"
      contains: "validate_plink_dimensions"
    - path: "tests/test_cli.py"
      provides: "CLI tests for new flags in help output"
      contains: "-snps"
    - path: "tests/test_plink_validation.py"
      provides: "Tests for dimension and genotype value validation"
      contains: "validate_plink_dimensions"
  key_links:
    - from: "src/jamma/cli.py"
      to: "src/jamma/pipeline.py"
      via: "PipelineConfig snps_file, ksnps_file, hwe_threshold fields"
      pattern: "snps_file="
    - from: "src/jamma/pipeline.py"
      to: "src/jamma/io/snp_list.py"
      via: "PipelineRunner reads SNP list files and resolves to indices"
      pattern: "read_snp_list_file"
    - from: "src/jamma/pipeline.py"
      to: "src/jamma/lmm/runner_streaming.py"
      via: "passes snps_indices and hwe_threshold to run_lmm_association_streaming"
      pattern: "snps_indices="
    - from: "src/jamma/pipeline.py"
      to: "src/jamma/kinship/compute.py"
      via: "passes ksnps_indices to compute_kinship_streaming"
      pattern: "ksnps_indices="
    - from: "src/jamma/pipeline.py"
      to: "src/jamma/io/plink.py"
      via: "validate_inputs calls validate_plink_dimensions"
      pattern: "validate_plink_dimensions"
---

<objective>
Wire CLI flags (-snps, -ksnps, -hwe), gwas() API, PipelineConfig, and PLINK input
validation (VALID-01, VALID-02) to complete Phase 28 end-to-end.

Purpose: The filtering engine from Plan 01 needs to be accessible to users through
both the CLI and Python API. PLINK dimension/value validation catches corrupted
input files before they cause cryptic errors deep in the pipeline.

Output: CLI flags, gwas() parameters, PipelineConfig fields, PLINK validation,
end-to-end tests proving the full flow works.
</objective>

<execution_context>
@/Users/mdenyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mdenyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/28-filtering-and-input-validation/28-RESEARCH.md
@.planning/phases/28-filtering-and-input-validation/28-01-SUMMARY.md

@src/jamma/pipeline.py
@src/jamma/cli.py
@src/jamma/gwas.py
@src/jamma/io/plink.py
@tests/test_pipeline.py
@tests/test_cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PLINK dimension and genotype value validation</name>
  <files>
    src/jamma/io/plink.py
    src/jamma/pipeline.py
    tests/test_plink_validation.py
  </files>
  <action>
**Add validation functions to `src/jamma/io/plink.py`:**

1. `validate_plink_dimensions(bfile: Path) -> None`:
   - Count lines in .fam file (= n_samples) and .bim file (= n_snps).
   - Compute expected .bed file size: `3 + ((n_fam + 3) // 4) * n_bim` bytes
     (3 magic bytes + ceil(n_fam/4) bytes per SNP column).
   - Compare with actual .bed file size via `Path.stat().st_size`.
   - If mismatch, raise `ValueError` with clear message:
     "PLINK dimension mismatch: .fam has {n_fam} samples, .bim has {n_bim} SNPs,
     but .bed file size ({actual} bytes) doesn't match expected ({expected} bytes)"
   - If all three files don't exist, raise FileNotFoundError.
   - Docstring: Google-style, note this enhances bed_reader's built-in check
     with a more informative error message.

2. `validate_genotype_values(chunk: np.ndarray) -> int`:
   - Check that all non-NaN values are in {0.0, 1.0, 2.0}.
   - `valid_mask = np.isnan(chunk) | (chunk == 0) | (chunk == 1) | (chunk == 2)`
   - Return `int(np.sum(~valid_mask))` -- count of unexpected values.
   - This is called per-chunk during pass-1; the caller accumulates the total
     and logs a single summary warning at the end.

**Integrate validation into `src/jamma/pipeline.py`:**

3. In `PipelineRunner.validate_inputs()`, after the existing PLINK file existence
   checks, call `validate_plink_dimensions(self.config.bfile)`. Import from
   `jamma.io.plink`. This provides VALID-01.

4. For VALID-02 (genotype value validation): This is best implemented as an
   accumulator in the pass-1 streaming loops. However, since pass-1 lives inside
   `runner_streaming.py` (already modified in Plan 01), and the pipeline owns the
   config, add a `validate_genotypes: bool = True` field to PipelineConfig (default
   True). The runner will check this and call `validate_genotype_values` per chunk
   during pass-1, accumulating a total. After pass-1, if total > 0, log a warning:
   `"WARNING: {n} genotype values outside expected range {0, 1, 2, NaN} found"`

   Actually, simpler approach: add the validation call directly in
   `runner_streaming.py` pass-1 loop (it's already being modified in Plan 01).
   Add parameter `validate_genotypes: bool = True` to `run_lmm_association_streaming`.
   Inside pass-1 loop, after existing stats computation:
   ```python
   if validate_genotypes:
       n_unexpected_total += validate_genotype_values(chunk)
   ```
   After pass-1 loop:
   ```python
   if validate_genotypes and n_unexpected_total > 0:
       logger.warning(
           f"Genotype validation: {n_unexpected_total} values outside "
           f"expected range {{0, 1, 2, NaN}}"
       )
   ```
   Import `validate_genotype_values` from `jamma.io.plink`.

**Create `tests/test_plink_validation.py`:**

5. `test_validate_plink_dimensions_valid`: Use gemma_synthetic fixture.
   Call `validate_plink_dimensions` -- should not raise.

6. `test_validate_plink_dimensions_truncated_bed`: Copy gemma_synthetic .bed to
   tmp, truncate by 10 bytes. Call validate -- should raise ValueError with
   "dimension mismatch" in message.

7. `test_validate_plink_dimensions_missing_files`: Non-existent prefix.
   Should raise FileNotFoundError.

8. `test_validate_genotype_values_all_valid`: Chunk with only 0, 1, 2, NaN.
   Returns 0.

9. `test_validate_genotype_values_with_unexpected`: Chunk with a value of 3.0
   and -1.0. Returns 2.

10. `test_validate_genotype_values_all_nan`: All-NaN chunk. Returns 0.
  </action>
  <verify>
`uv run pytest tests/test_plink_validation.py -x -v` -- all tests pass.
`uv run ruff check src/jamma/io/plink.py src/jamma/pipeline.py` -- clean lint.
  </verify>
  <done>
PLINK dimension validation catches corrupted .bed files with clear error messages.
Genotype value validation counts unexpected values per chunk. Both are integrated
into the pipeline. VALID-01 and VALID-02 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI flags, gwas() API, PipelineConfig wiring, and end-to-end tests</name>
  <files>
    src/jamma/pipeline.py
    src/jamma/cli.py
    src/jamma/gwas.py
    tests/test_pipeline.py
    tests/test_cli.py
  </files>
  <action>
**Update `src/jamma/pipeline.py` PipelineConfig:**

1. Add fields to PipelineConfig dataclass:
   - `snps_file: Path | None = None` -- SNP list file for association restriction
   - `ksnps_file: Path | None = None` -- SNP list file for kinship restriction
   - `hwe_threshold: float = 0.0` -- HWE p-value threshold (0 = disabled)
   Document each field in the class docstring Attributes section.

2. In `validate_inputs()`:
   - Validate snps_file exists if not None.
   - Validate ksnps_file exists if not None.
   - Validate hwe_threshold >= 0 (raise ValueError if negative).

3. In `PipelineRunner.run()`:
   - After `get_plink_metadata()`, resolve SNP list files to indices:
     ```python
     snps_indices = None
     ksnps_indices = None
     if self.config.snps_file is not None:
         from jamma.io.snp_list import read_snp_list_file, resolve_snp_list_to_indices
         snp_ids = read_snp_list_file(self.config.snps_file)
         snps_indices = resolve_snp_list_to_indices(snp_ids, meta["sid"])
         logger.info(f"SNP list (-snps): {len(snps_indices)} SNPs to test")
     if self.config.ksnps_file is not None:
         from jamma.io.snp_list import read_snp_list_file, resolve_snp_list_to_indices
         ksnp_ids = read_snp_list_file(self.config.ksnps_file)
         ksnps_indices = resolve_snp_list_to_indices(ksnp_ids, meta["sid"])
         logger.info(f"Kinship SNP list (-ksnps): {len(ksnps_indices)} SNPs for kinship")
     ```
   - Pass `ksnps_indices` to `compute_kinship_streaming()` in `load_kinship()`.
     This requires either passing ksnps_indices as a parameter to load_kinship,
     or resolving it inside run() and passing. Cleanest: add ksnps_indices param
     to load_kinship, pass from run().
   - Pass `snps_indices` and `hwe_threshold=self.config.hwe_threshold` to
     `run_lmm_association_streaming()`.
   - For LOCO branch: pass `ksnps_indices` to `compute_loco_kinship_streaming()`
     (via the loco_iter call) and `snps_indices` to `run_lmm_loco()`.

4. Update `load_kinship()` signature to accept `ksnps_indices: np.ndarray | None = None`
   and pass it to `compute_kinship_streaming(..., ksnps_indices=ksnps_indices)`.

**Update `src/jamma/gwas.py`:**

5. Add parameters to `gwas()`:
   - `snps_file: str | Path | None = None`
   - `ksnps_file: str | Path | None = None`
   - `hwe: float = 0.0`
   Pass to PipelineConfig as `snps_file`, `ksnps_file`, `hwe_threshold`.
   Update docstring with descriptions matching GEMMA's -snps, -ksnps, -hwe flags.

**Update `src/jamma/cli.py`:**

6. Add flags to `lmm_command`:
   ```python
   snps_file: Annotated[
       Path | None,
       typer.Option("-snps", help="File with SNP IDs to restrict association testing"),
   ] = None,
   ksnps_file: Annotated[
       Path | None,
       typer.Option("-ksnps", help="File with SNP IDs to restrict kinship computation"),
   ] = None,
   hwe_threshold: Annotated[
       float,
       typer.Option("-hwe", help="HWE p-value threshold (exclude SNPs with p < threshold)"),
   ] = 0.0,
   ```
   Pass to PipelineConfig: `snps_file=snps_file, ksnps_file=ksnps_file,
   hwe_threshold=hwe_threshold`.

7. Add `-ksnps` flag to `gk_command`:
   ```python
   ksnps_file: Annotated[
       Path | None,
       typer.Option("-ksnps", help="File with SNP IDs to restrict kinship computation"),
   ] = None,
   ```
   When ksnps_file is provided in gk_command, resolve to indices and pass to
   the kinship computation function. For the non-streaming path (load_plink_binary
   + compute_centered_kinship), this requires filtering the genotype matrix before
   passing to compute_centered_kinship. For the LOCO streaming path, pass
   ksnps_indices to `compute_loco_kinship_streaming`.
   For non-streaming gk: after loading plink_data, resolve ksnps, then filter
   genotypes before passing to compute_fn:
   ```python
   if ksnps_file is not None:
       from jamma.io.snp_list import read_snp_list_file, resolve_snp_list_to_indices
       ksnp_ids = read_snp_list_file(ksnps_file)
       ksnps_idx = resolve_snp_list_to_indices(ksnp_ids, plink_data.sid)
       genotypes = plink_data.genotypes[:, ksnps_idx]
   else:
       genotypes = plink_data.genotypes
   ```
   Then pass `genotypes` to `compute_fn(genotypes, ...)`.

**Add tests to `tests/test_cli.py`:**

8. `test_cli_lmm_snps_flag_in_help`: Verify "-snps" appears in lmm help output.
9. `test_cli_lmm_ksnps_flag_in_help`: Verify "-ksnps" appears in lmm help output.
10. `test_cli_lmm_hwe_flag_in_help`: Verify "-hwe" appears in lmm help output.
11. `test_cli_gk_ksnps_flag_in_help`: Verify "-ksnps" appears in gk help output.

**Add tests to `tests/test_pipeline.py`:**

12. `test_pipeline_config_snps_fields`: Verify PipelineConfig accepts snps_file,
    ksnps_file, hwe_threshold with correct defaults (None, None, 0.0).

13. `test_pipeline_validate_inputs_snps_file_not_found`: Set snps_file to
    non-existent path, verify validate_inputs raises FileNotFoundError.

14. `test_pipeline_validate_inputs_negative_hwe`: Set hwe_threshold=-0.1,
    verify validate_inputs raises ValueError.
  </action>
  <verify>
`uv run pytest tests/test_cli.py tests/test_pipeline.py tests/test_plink_validation.py -x -v` -- all tests pass.
`uv run pytest tests/ -x` -- full test suite passes.
`uv run ruff check .` -- clean lint.
  </verify>
  <done>
CLI exposes -snps, -ksnps, -hwe on lmm command and -ksnps on gk command.
gwas() API has snps_file, ksnps_file, hwe parameters. PipelineConfig stores
the new fields, validate_inputs checks file existence and parameter ranges.
PipelineRunner.run() resolves SNP list files to indices and passes through
to streaming runners and kinship computation. PLINK dimension validation runs
in validate_inputs. All requirements SNP-01, SNP-02, SNP-03, QC-01, QC-02,
VALID-01, VALID-02 satisfied end-to-end.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/ -x` -- full test suite passes
- `uv run ruff check .` -- clean lint
- `jamma lmm -bfile data -k k.txt -snps snp_list.txt` restricts association to listed SNPs
- `jamma gk -bfile data -ksnps ksnp_list.txt` restricts kinship to listed SNPs
- `jamma lmm -bfile data -k k.txt -hwe 0.001` excludes HWE-failing SNPs
- Truncated .bed file produces clear dimension mismatch error
- Default behavior (no new flags) produces identical results to before
</verification>

<success_criteria>
- CLI flags -snps, -ksnps, -hwe visible in help output
- gwas() accepts snps_file, ksnps_file, hwe parameters
- PipelineConfig stores and validates new fields
- PipelineRunner resolves SNP list files and passes indices to runners
- PLINK dimension validation catches corrupted files
- Genotype value validation warns on unexpected values
- All existing tests pass unchanged (backward compatible)
- Full end-to-end: SNP list + HWE + validation work through CLI and API
</success_criteria>

<output>
After completion, create `.planning/phases/28-filtering-and-input-validation/28-02-SUMMARY.md`
</output>
