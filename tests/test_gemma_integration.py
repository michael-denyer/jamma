"""Integration tests comparing JAMMA to pre-computed GEMMA reference outputs.

These tests use fixture data generated by GEMMA 0.96 on synthetic genotypes
to validate JAMMA produces numerically equivalent results.

Fixture data:
- tests/fixtures/gemma_synthetic/test.{bed,bim,fam} - PLINK files (100x500)
- tests/fixtures/gemma_synthetic/gemma_kinship.cXX.txt - GEMMA kinship matrix
- tests/fixtures/gemma_synthetic/gemma_assoc.assoc.txt - GEMMA LMM results

The synthetic data has:
- 100 samples, 500 SNPs
- Hardy-Weinberg genotype frequencies (MAF 0.1-0.9)
- Causal SNP at rs0000 with effect size 0.5
- Phenotype: 0.5 * genotype[SNP0] + noise, standardized
"""

from pathlib import Path

import numpy as np
import pandas as pd
import pytest
from scipy.stats import spearmanr

from jamma.io import load_plink_binary
from jamma.kinship import compute_centered_kinship
from jamma.lmm.runner_jax import run_lmm_association_jax
from jamma.validation import load_gemma_kinship

# Fixture paths
FIXTURE_DIR = Path("tests/fixtures/gemma_synthetic")
PLINK_PREFIX = FIXTURE_DIR / "test"
GEMMA_KINSHIP = FIXTURE_DIR / "gemma_kinship.cXX.txt"
GEMMA_ASSOC = FIXTURE_DIR / "gemma_assoc.assoc.txt"


def load_phenotypes_from_fam(fam_path: Path) -> np.ndarray:
    """Load phenotypes from FAM file (column 6)."""
    phenotypes = []
    with open(fam_path) as f:
        for line in f:
            fields = line.strip().split()
            phenotypes.append(float(fields[5]))
    return np.array(phenotypes, dtype=np.float64)


@pytest.fixture
def plink_data():
    """Load synthetic PLINK data."""
    return load_plink_binary(PLINK_PREFIX)


@pytest.fixture
def phenotypes():
    """Load phenotypes from FAM file."""
    return load_phenotypes_from_fam(PLINK_PREFIX.with_suffix(".fam"))


@pytest.fixture
def gemma_kinship():
    """Load pre-computed GEMMA kinship matrix."""
    return load_gemma_kinship(GEMMA_KINSHIP)


@pytest.fixture
def gemma_assoc():
    """Load pre-computed GEMMA association results."""
    return pd.read_csv(GEMMA_ASSOC, sep="\t")


class TestGemmaKinshipValidation:
    """Validate JAMMA kinship against pre-computed GEMMA reference."""

    def test_kinship_matches_gemma(self, plink_data, gemma_kinship):
        """JAMMA kinship matches GEMMA within tight tolerance."""
        jamma_kinship = compute_centered_kinship(plink_data.genotypes)

        max_abs_diff = np.max(np.abs(gemma_kinship - jamma_kinship))
        assert max_abs_diff < 1e-10, f"Kinship max abs diff {max_abs_diff:.2e} >= 1e-10"

    def test_kinship_shape_matches(self, plink_data, gemma_kinship):
        """JAMMA and GEMMA produce same shape kinship matrix."""
        jamma_kinship = compute_centered_kinship(plink_data.genotypes)
        assert jamma_kinship.shape == gemma_kinship.shape

    def test_kinship_symmetric(self, plink_data, gemma_kinship):
        """Both JAMMA and GEMMA kinship are symmetric."""
        jamma_kinship = compute_centered_kinship(plink_data.genotypes)

        assert np.allclose(gemma_kinship, gemma_kinship.T), (
            "GEMMA kinship not symmetric"
        )
        assert np.allclose(jamma_kinship, jamma_kinship.T), (
            "JAMMA kinship not symmetric"
        )

    def test_kinship_deterministic(self, plink_data):
        """JAMMA kinship is deterministic."""
        k1 = compute_centered_kinship(plink_data.genotypes)
        k2 = compute_centered_kinship(plink_data.genotypes)
        assert np.array_equal(k1, k2), "JAMMA kinship is not deterministic"


class TestGemmaLmmValidation:
    """Validate JAMMA LMM against pre-computed GEMMA reference."""

    @pytest.fixture
    def jamma_assoc(self, plink_data, phenotypes, gemma_kinship):
        """Run JAMMA LMM association using GEMMA kinship."""
        genotypes = plink_data.genotypes
        n_snps = genotypes.shape[1]

        # Build SNP info from PLINK metadata
        snp_info = [
            {
                "chr": str(plink_data.chromosome[i]),
                "rs": str(plink_data.sid[i]),
                "pos": int(plink_data.bp_position[i]),
                "a1": str(plink_data.allele_1[i]),
                "a0": str(plink_data.allele_2[i]),
                "maf": 0.0,
                "n_miss": 0,
            }
            for i in range(n_snps)
        ]

        results = run_lmm_association_jax(
            genotypes,
            phenotypes,
            gemma_kinship,
            snp_info,
            maf_threshold=0.0,
            miss_threshold=1.0,
            show_progress=False,
            check_memory=False,
        )

        return pd.DataFrame(
            [
                {
                    "rs": r.rs,
                    "beta": r.beta,
                    "se": r.se,
                    "p_wald": r.p_wald,
                    "l_remle": r.l_remle,
                    "logl_H1": r.logl_H1,
                }
                for r in results
            ]
        )

    def test_lmm_beta_matches_gemma(self, gemma_assoc, jamma_assoc):
        """JAMMA beta estimates match GEMMA within tolerance."""
        merged = pd.merge(
            gemma_assoc, jamma_assoc, on="rs", suffixes=("_gemma", "_jamma")
        )

        beta_diff = np.abs(merged["beta_gemma"] - merged["beta_jamma"])
        max_beta_diff = np.max(beta_diff)

        # Expect much better than tolerances.py beta_rtol=1e-2
        assert max_beta_diff < 1e-5, f"Beta max abs diff {max_beta_diff:.2e} >= 1e-5"

    def test_lmm_se_matches_gemma(self, gemma_assoc, jamma_assoc):
        """JAMMA standard errors match GEMMA within tolerance."""
        merged = pd.merge(
            gemma_assoc, jamma_assoc, on="rs", suffixes=("_gemma", "_jamma")
        )

        se_diff = np.abs(merged["se_gemma"] - merged["se_jamma"])
        max_se_diff = np.max(se_diff)

        assert max_se_diff < 1e-6, f"SE max abs diff {max_se_diff:.2e} >= 1e-6"

    def test_lmm_pvalue_matches_gemma(self, gemma_assoc, jamma_assoc):
        """JAMMA p-values match GEMMA within tolerance."""
        merged = pd.merge(
            gemma_assoc, jamma_assoc, on="rs", suffixes=("_gemma", "_jamma")
        )

        pval_diff = np.abs(merged["p_wald_gemma"] - merged["p_wald_jamma"])
        max_pval_diff = np.max(pval_diff)

        assert max_pval_diff < 1e-5, f"P-value max abs diff {max_pval_diff:.2e} >= 1e-5"

    def test_lmm_lambda_matches_gemma(self, gemma_assoc, jamma_assoc):
        """JAMMA lambda (variance ratio) matches GEMMA within tolerance."""
        merged = pd.merge(
            gemma_assoc, jamma_assoc, on="rs", suffixes=("_gemma", "_jamma")
        )

        lambda_diff = np.abs(merged["l_remle_gemma"] - merged["l_remle_jamma"])
        max_lambda_diff = np.max(lambda_diff)

        # lambda_rtol from tolerances.py = 2e-5
        assert max_lambda_diff < 2e-4, (
            f"Lambda max abs diff {max_lambda_diff:.2e} >= 2e-4"
        )

    def test_lmm_pvalue_rank_correlation(self, gemma_assoc, jamma_assoc):
        """JAMMA p-values have perfect rank correlation with GEMMA."""
        merged = pd.merge(
            gemma_assoc, jamma_assoc, on="rs", suffixes=("_gemma", "_jamma")
        )

        rho, _ = spearmanr(merged["p_wald_gemma"], merged["p_wald_jamma"])
        assert rho > 0.9999, f"P-value rank correlation {rho:.6f} < 0.9999"

    def test_lmm_top_hits_match(self, gemma_assoc, jamma_assoc):
        """JAMMA and GEMMA identify the same top 5 hits."""
        gemma_top5 = set(gemma_assoc.nsmallest(5, "p_wald")["rs"])
        jamma_top5 = set(jamma_assoc.nsmallest(5, "p_wald")["rs"])

        assert gemma_top5 == jamma_top5, (
            f"Top 5 mismatch: GEMMA={gemma_top5}, JAMMA={jamma_top5}"
        )

    def test_lmm_causal_snp_is_top_hit(self, gemma_assoc, jamma_assoc):
        """Both JAMMA and GEMMA detect the causal SNP (rs0000) as top hit."""
        gemma_top1 = gemma_assoc.nsmallest(1, "p_wald")["rs"].iloc[0]
        jamma_top1 = jamma_assoc.nsmallest(1, "p_wald")["rs"].iloc[0]

        assert gemma_top1 == "rs0000", f"GEMMA top hit is {gemma_top1}, expected rs0000"
        assert jamma_top1 == "rs0000", f"JAMMA top hit is {jamma_top1}, expected rs0000"

    def test_lmm_all_snps_present(self, gemma_assoc, jamma_assoc):
        """JAMMA produces results for all SNPs."""
        assert len(jamma_assoc) == len(gemma_assoc), (
            f"SNP count mismatch: JAMMA={len(jamma_assoc)}, GEMMA={len(gemma_assoc)}"
        )


class TestGemmaSyntheticDataProperties:
    """Verify properties of the synthetic fixture data."""

    def test_fixture_data_exists(self):
        """All fixture files exist."""
        assert PLINK_PREFIX.with_suffix(".bed").exists(), "Missing test.bed"
        assert PLINK_PREFIX.with_suffix(".bim").exists(), "Missing test.bim"
        assert PLINK_PREFIX.with_suffix(".fam").exists(), "Missing test.fam"
        assert GEMMA_KINSHIP.exists(), "Missing gemma_kinship.cXX.txt"
        assert GEMMA_ASSOC.exists(), "Missing gemma_assoc.assoc.txt"

    def test_plink_data_dimensions(self, plink_data):
        """PLINK data has expected dimensions."""
        assert plink_data.n_samples == 100, (
            f"Expected 100 samples, got {plink_data.n_samples}"
        )
        assert plink_data.n_snps == 500, f"Expected 500 SNPs, got {plink_data.n_snps}"

    def test_gemma_kinship_dimensions(self, gemma_kinship):
        """GEMMA kinship has expected dimensions."""
        assert gemma_kinship.shape == (
            100,
            100,
        ), f"Expected (100, 100), got {gemma_kinship.shape}"

    def test_gemma_assoc_snp_count(self, gemma_assoc):
        """GEMMA association results have expected SNP count."""
        assert len(gemma_assoc) == 500, f"Expected 500 SNPs, got {len(gemma_assoc)}"

    def test_causal_snp_has_significant_pvalue(self, gemma_assoc):
        """Causal SNP rs0000 has a significant p-value in GEMMA results."""
        rs0000_pval = gemma_assoc[gemma_assoc["rs"] == "rs0000"]["p_wald"].iloc[0]
        assert rs0000_pval < 0.001, f"Causal SNP p-value {rs0000_pval} >= 0.001"
