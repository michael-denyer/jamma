"""Validation tests for LMM association against GEMMA reference.

These tests verify JAMMA LMM produces numerically consistent results
that match reference GEMMA output within tolerance.

Note: These tests require reference data generated by GEMMA.
Run scripts/generate_lmm_reference.sh to generate fixtures.
"""

from pathlib import Path

import numpy as np
import pytest

from jamma.core import configure_jax
from jamma.io import load_plink_binary
from jamma.kinship import compute_centered_kinship
from jamma.kinship.io import read_kinship_matrix
from jamma.lmm.io import write_assoc_results
from jamma.lmm.runner_jax import run_lmm_association_jax
from jamma.lmm.stats import AssocResult
from jamma.validation import (
    AssocComparisonResult,
    ToleranceConfig,
    compare_assoc_results,
    load_gemma_assoc,
)

# JAX golden section optimizer produces slightly different lambda values than
# GEMMA's Brent method. Use lambda_rtol=5e-5 (documented bound) for all
# GEMMA parity tests that now use the JAX runner.
JAX_GEMMA_TOLERANCES = ToleranceConfig(lambda_rtol=5e-5)

# Test data paths - use gemma_synthetic which has matching PLINK + reference outputs
EXAMPLE_DATA = Path("tests/fixtures/gemma_synthetic/test")
REFERENCE_KINSHIP = Path("tests/fixtures/gemma_synthetic/gemma_kinship.cXX.txt")
REFERENCE_ASSOC = Path("tests/fixtures/gemma_synthetic/gemma_assoc.assoc.txt")

# Covariate validation paths
COVARIATE_FIXTURE_DIR = Path("tests/fixtures/gemma_covariate")
COVARIATE_FILE = COVARIATE_FIXTURE_DIR / "covariates.txt"
COVARIATE_REFERENCE_ASSOC = COVARIATE_FIXTURE_DIR / "gemma_covariate.assoc.txt"

# Score test validation path
SCORE_REFERENCE_ASSOC = Path("tests/fixtures/gemma_score/gemma_score.assoc.txt")

# All-tests (-lmm 4) validation paths
ALL_TESTS_FIXTURE_DIR = Path("tests/fixtures/gemma_all_tests")
ALL_TESTS_REFERENCE = ALL_TESTS_FIXTURE_DIR / "gemma_all.assoc.txt"
ALL_TESTS_COVAR_REFERENCE = ALL_TESTS_FIXTURE_DIR / "gemma_all_covar.assoc.txt"

# Mouse HS1940 validation paths
MOUSE_HS1940_DIR = Path("tests/fixtures/mouse_hs1940")
MOUSE_HS1940_DATA = MOUSE_HS1940_DIR / "mouse_hs1940"
MOUSE_HS1940_KINSHIP = MOUSE_HS1940_DIR / "mouse_hs1940_kinship.cXX.txt"
MOUSE_HS1940_COVARIATES = MOUSE_HS1940_DIR / "covariates.txt"
MOUSE_HS1940_LRT = MOUSE_HS1940_DIR / "mouse_hs1940_lrt.assoc.txt"
MOUSE_HS1940_SCORE = MOUSE_HS1940_DIR / "mouse_hs1940_score.assoc.txt"
MOUSE_HS1940_ALL = MOUSE_HS1940_DIR / "mouse_hs1940_all.assoc.txt"
MOUSE_HS1940_COVAR_WALD = MOUSE_HS1940_DIR / "mouse_hs1940_covar_wald.assoc.txt"
MOUSE_HS1940_COVAR_LRT = MOUSE_HS1940_DIR / "mouse_hs1940_covar_lrt.assoc.txt"
MOUSE_HS1940_COVAR_SCORE = MOUSE_HS1940_DIR / "mouse_hs1940_covar_score.assoc.txt"
MOUSE_HS1940_COVAR_ALL = MOUSE_HS1940_DIR / "mouse_hs1940_covar_all.assoc.txt"


def _score_reference_exists():
    """Check if Score test reference file exists."""
    return SCORE_REFERENCE_ASSOC.exists()


def _all_tests_reference_exists():
    """Check if all-tests (-lmm 4) reference files exist."""
    return ALL_TESTS_REFERENCE.exists()


def _mouse_hs1940_exists():
    """Check if mouse_hs1940 PLINK data exists."""
    return MOUSE_HS1940_DATA.with_suffix(".bed").exists()


@pytest.fixture(autouse=True)
def setup_jax():
    """Configure JAX with 64-bit precision before each test."""
    configure_jax(enable_x64=True)


@pytest.fixture
def mouse_data():
    """Load gemma_synthetic PLINK data."""
    return load_plink_binary(EXAMPLE_DATA)


@pytest.fixture
def mouse_phenotypes():
    """Load phenotypes from PLINK .fam file (column 6)."""
    fam_path = EXAMPLE_DATA.with_suffix(".fam")
    phenotypes = []
    with open(fam_path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) >= 6:
                val = parts[5]
                if val == "-9" or val == "NA":
                    phenotypes.append(np.nan)
                else:
                    phenotypes.append(float(val))
    return np.array(phenotypes)


@pytest.fixture
def reference_kinship():
    """Load reference kinship matrix."""
    return read_kinship_matrix(REFERENCE_KINSHIP)


@pytest.fixture
def hs1940_data():
    """Load mouse_hs1940 PLINK data."""
    if not _mouse_hs1940_exists():
        pytest.skip("mouse_hs1940 PLINK data not found")
    return load_plink_binary(MOUSE_HS1940_DATA)


@pytest.fixture
def hs1940_phenotypes():
    """Load mouse_hs1940 phenotypes from .fam file."""
    fam_path = MOUSE_HS1940_DATA.with_suffix(".fam")
    if not fam_path.exists():
        pytest.skip("mouse_hs1940 .fam not found")
    phenotypes = []
    with open(fam_path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) >= 6:
                val = parts[5]
                if val == "-9" or val == "NA":
                    phenotypes.append(np.nan)
                else:
                    phenotypes.append(float(val))
    return np.array(phenotypes)


@pytest.fixture
def hs1940_kinship():
    """Load mouse_hs1940 kinship matrix."""
    if not MOUSE_HS1940_KINSHIP.exists():
        pytest.skip("mouse_hs1940 kinship not found")
    return read_kinship_matrix(MOUSE_HS1940_KINSHIP)


@pytest.fixture
def hs1940_covariates():
    """Load mouse_hs1940 covariates."""
    if not MOUSE_HS1940_COVARIATES.exists():
        pytest.skip("mouse_hs1940 covariates not found")
    return np.loadtxt(MOUSE_HS1940_COVARIATES)


class TestLmmValidation:
    """Tests validating JAMMA LMM against GEMMA reference."""

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_matches_reference(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAMMA LMM matches GEMMA reference within tolerance."""
        # Load reference results
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        # Extract data from PLINK
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes

        # Build SNP info from PlinkData
        snp_info = _build_snp_info(mouse_data)

        # Run JAMMA LMM
        jamma_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        # Compare results
        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )

        # Assert overall pass
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_beta_tolerance(self, mouse_data, mouse_phenotypes, reference_kinship):
        """Effect sizes match within beta_rtol tolerance."""
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jamma_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )

        assert comparison.beta.passed, (
            f"Beta comparison failed: {comparison.beta.message}\n"
            f"Max abs diff: {comparison.beta.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.beta.max_rel_diff:.2e}"
        )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_pvalue_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """P-values match within pvalue_rtol tolerance."""
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jamma_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )

        assert comparison.p_wald.passed, (
            f"P-value comparison failed: {comparison.p_wald.message}\n"
            f"Max abs diff: {comparison.p_wald.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_wald.max_rel_diff:.2e}"
        )


class TestLmmOutputFormat:
    """Tests for LMM output format compatibility."""

    def test_assoc_output_roundtrip(self, tmp_path):
        """AssocResult can be written and read back."""
        results = [
            AssocResult(
                chr="1",
                rs="rs123",
                ps=12345,
                n_miss=0,
                allele1="A",
                allele0="G",
                af=0.25,
                beta=1.234567e-3,
                se=5.678901e-4,
                logl_H1=-1234.567890,
                l_remle=2.345678,
                p_wald=1.234567e-8,
            ),
            AssocResult(
                chr="2",
                rs="rs456",
                ps=67890,
                n_miss=5,
                allele1="T",
                allele0="C",
                af=0.123,
                beta=-2.345678e-2,
                se=1.234567e-3,
                logl_H1=-2345.678901,
                l_remle=0.987654,
                p_wald=5.678901e-5,
            ),
        ]

        # Write to file
        output_path = tmp_path / "test.assoc.txt"
        write_assoc_results(results, output_path)

        # Read back
        loaded = load_gemma_assoc(output_path)

        assert len(loaded) == len(results)
        for orig, loaded_result in zip(results, loaded, strict=True):
            assert orig.chr == loaded_result.chr
            assert orig.rs == loaded_result.rs
            assert orig.ps == loaded_result.ps
            assert orig.n_miss == loaded_result.n_miss
            assert orig.allele1 == loaded_result.allele1
            assert orig.allele0 == loaded_result.allele0
            # Numeric fields have some precision loss
            assert np.isclose(orig.af, loaded_result.af, rtol=1e-3)
            assert np.isclose(orig.beta, loaded_result.beta, rtol=1e-6)
            assert np.isclose(orig.se, loaded_result.se, rtol=1e-6)

    def test_assoc_output_header(self, tmp_path):
        """Output file has correct header."""
        results = [
            AssocResult(
                chr="1",
                rs="rs1",
                ps=1,
                n_miss=0,
                allele1="A",
                allele0="T",
                af=0.5,
                beta=0.0,
                se=0.1,
                logl_H1=-50.0,
                l_remle=1.0,
                p_wald=1.0,
            )
        ]

        output_path = tmp_path / "test.assoc.txt"
        write_assoc_results(results, output_path)

        with open(output_path) as f:
            header = f.readline().strip()

        expected = (
            "chr\trs\tps\tn_miss\tallele1\tallele0\t"
            "af\tbeta\tse\tlogl_H1\tl_remle\tp_wald"
        )
        assert header == expected

    def test_all_tests_output_roundtrip(self, tmp_path):
        """All-tests output can be written and read back correctly.

        JAMMA -lmm 4 writes 15 columns (includes logl_H1), while GEMMA
        -lmm 4 writes 14 columns (no logl_H1). The roundtrip test verifies
        JAMMA's 15-column format by direct file parsing, since
        load_gemma_assoc only handles the 14-column GEMMA format.
        """
        from jamma.lmm.io import IncrementalAssocWriter

        results = [
            AssocResult(
                chr="1",
                rs="rs100",
                ps=10000,
                n_miss=0,
                allele1="A",
                allele0="G",
                af=0.350,
                beta=1.234567e-3,
                se=5.678901e-4,
                logl_H1=-1234.567890,
                l_remle=2.345678,
                l_mle=2.456789,
                p_wald=1.234567e-8,
                p_lrt=2.345678e-7,
                p_score=3.456789e-6,
            ),
            AssocResult(
                chr="2",
                rs="rs200",
                ps=20000,
                n_miss=3,
                allele1="T",
                allele0="C",
                af=0.123,
                beta=-2.345678e-2,
                se=1.234567e-3,
                logl_H1=-2345.678901,
                l_remle=0.987654,
                l_mle=1.012345,
                p_wald=5.678901e-5,
                p_lrt=6.789012e-4,
                p_score=7.890123e-3,
            ),
        ]

        # Write using IncrementalAssocWriter in all-tests mode
        output_path = tmp_path / "all_tests.assoc.txt"
        with IncrementalAssocWriter(output_path, test_type="all") as writer:
            for r in results:
                writer.write(r)

        # Read back and verify by direct parsing (15-column format)
        with open(output_path) as f:
            header = f.readline().strip()
            cols = header.split("\t")
            assert len(cols) == 15, f"Expected 15 columns, got {len(cols)}"

            lines = f.readlines()
            assert len(lines) == 2, f"Expected 2 data lines, got {len(lines)}"

        # Verify each line can be parsed back
        with open(output_path) as f:
            f.readline()  # skip header
            for i, line in enumerate(f):
                fields = line.strip().split("\t")
                assert (
                    len(fields) == 15
                ), f"Line {i} has {len(fields)} fields, expected 15"
                orig = results[i]
                assert fields[0] == orig.chr
                assert fields[1] == orig.rs
                assert int(fields[2]) == orig.ps
                assert int(fields[3]) == orig.n_miss
                assert fields[4] == orig.allele1
                assert fields[5] == orig.allele0
                assert np.isclose(float(fields[6]), orig.af, rtol=1e-3)
                assert np.isclose(float(fields[7]), orig.beta, rtol=1e-6)
                assert np.isclose(float(fields[8]), orig.se, rtol=1e-6)
                assert np.isclose(float(fields[9]), orig.logl_H1, rtol=1e-6)
                assert np.isclose(float(fields[10]), orig.l_remle, rtol=1e-6)
                assert np.isclose(float(fields[11]), orig.l_mle, rtol=1e-6)
                assert np.isclose(float(fields[12]), orig.p_wald, rtol=1e-6)
                assert np.isclose(float(fields[13]), orig.p_lrt, rtol=1e-6)
                assert np.isclose(float(fields[14]), orig.p_score, rtol=1e-6)

    def test_all_tests_output_header(self, tmp_path):
        """All-tests output has correct 15-column JAMMA header."""
        from jamma.lmm.io import IncrementalAssocWriter

        result = AssocResult(
            chr="1",
            rs="rs1",
            ps=1,
            n_miss=0,
            allele1="A",
            allele0="T",
            af=0.5,
            beta=0.0,
            se=0.1,
            logl_H1=-50.0,
            l_remle=1.0,
            l_mle=1.1,
            p_wald=0.5,
            p_lrt=0.6,
            p_score=0.7,
        )

        output_path = tmp_path / "all_tests_header.assoc.txt"
        with IncrementalAssocWriter(output_path, test_type="all") as writer:
            writer.write(result)

        with open(output_path) as f:
            header = f.readline().strip()

        expected = (
            "chr\trs\tps\tn_miss\tallele1\tallele0\taf\t"
            "beta\tse\tlogl_H1\tl_remle\tl_mle\t"
            "p_wald\tp_lrt\tp_score"
        )
        assert header == expected


class TestLmmSmallScale:
    """Tests with smaller synthetic data for faster CI."""

    @pytest.fixture
    def small_data(self):
        """Small synthetic genetic data."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 50

        # Genotypes (0, 1, 2)
        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)

        # Phenotype with genetic component
        true_beta = rng.standard_normal(n_snps) * 0.1
        genetic_value = genotypes @ true_beta
        phenotypes = genetic_value + rng.standard_normal(n_samples)

        # Kinship matrix
        kinship = compute_centered_kinship(genotypes)

        # SNP info - use format expected by run_lmm_association_jax
        snp_info = [
            {
                "chr": "1",
                "rs": f"rs{i}",
                "pos": i * 1000,
                "a1": "A",
                "a0": "G",
                "maf": 0.25,
                "n_miss": 0,
            }
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_small_lmm_runs(self, small_data):
        """LMM runs without errors on small data."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        assert len(results) == genotypes.shape[1]

    def test_small_lmm_valid_pvalues(self, small_data):
        """All p-values are in [0, 1]."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        for result in results:
            assert 0.0 <= result.p_wald <= 1.0, f"Invalid p-value: {result.p_wald}"

    def test_small_lmm_positive_se(self, small_data):
        """All standard errors are positive."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        for result in results:
            assert result.se > 0, f"Invalid SE: {result.se}"

    def test_small_lmm_deterministic(self, small_data):
        """Same input produces identical output."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results1 = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )
        results2 = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        for r1, r2 in zip(results1, results2, strict=True):
            assert r1.beta == r2.beta
            assert r1.se == r2.se
            assert r1.p_wald == r2.p_wald


class TestLmmWithMissingPhenotypes:
    """Tests for LMM with missing phenotype data."""

    @pytest.fixture
    def data_with_missing(self):
        """Data with missing phenotype values."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)

        # Set some phenotypes to missing (-9 or NaN)
        phenotypes[0:5] = -9.0
        phenotypes[10:15] = np.nan

        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {
                "chr": "1",
                "rs": f"rs{i}",
                "pos": i * 1000,
                "a1": "A",
                "a0": "G",
                "maf": 0.25,
                "n_miss": 0,
            }
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_missing_phenotypes_handled(self, data_with_missing):
        """LMM handles missing phenotypes without errors."""
        genotypes, phenotypes, kinship, snp_info = data_with_missing

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        # Should produce results for all SNPs
        assert len(results) == genotypes.shape[1]

        # No NaN values in output
        for result in results:
            assert np.isfinite(result.beta), f"NaN beta for {result.rs}"
            assert np.isfinite(result.se), f"NaN SE for {result.rs}"
            assert np.isfinite(result.p_wald), f"NaN p-value for {result.rs}"


def _build_snp_info(plink_data):
    """Build SNP info list from PLINK data."""
    return [
        {
            "chr": str(plink_data.chromosome[i]),
            "rs": plink_data.sid[i],
            "pos": plink_data.bp_position[i],
            "a1": plink_data.allele_1[i],
            "a0": plink_data.allele_2[i],
            "maf": 0.0,  # Will be computed during association
            "n_miss": 0,  # Will be computed during association
        }
        for i in range(plink_data.n_snps)
    ]


def _format_comparison_failure(comparison: AssocComparisonResult) -> str:
    """Format detailed comparison failure message."""
    lines = [
        "\n=== LMM VALIDATION FAILURE ===",
        f"N SNPs: {comparison.n_snps}",
        f"Mismatched SNPs: {len(comparison.mismatched_snps)}",
        "",
        "Column comparisons:",
        f"  beta:    {_status(comparison.beta)} {comparison.beta.message}",
        f"  se:      {_status(comparison.se)} {comparison.se.message}",
        f"  p_wald:  {_status(comparison.p_wald)} {comparison.p_wald.message}",
        f"  logl_H1: {_status(comparison.logl_H1)} {comparison.logl_H1.message}",
        f"  l_remle: {_status(comparison.l_remle)} {comparison.l_remle.message}",
        f"  af:      {_status(comparison.af)} {comparison.af.message}",
    ]
    # Add p_score if present (Score test or all-tests)
    if comparison.p_score is not None:
        lines.append(
            f"  p_score: {_status(comparison.p_score)} {comparison.p_score.message}"
        )
    # Add p_lrt if present (LRT or all-tests)
    if comparison.p_lrt is not None:
        lines.append(
            f"  p_lrt:   {_status(comparison.p_lrt)} {comparison.p_lrt.message}"
        )
    # Add l_mle if present (LRT or all-tests)
    if comparison.l_mle is not None:
        lines.append(
            f"  l_mle:   {_status(comparison.l_mle)} {comparison.l_mle.message}"
        )
    lines.append("=============================")
    return "\n".join(lines)


def _status(result) -> str:
    """Return PASS or FAIL indicator."""
    return "PASS" if result.passed else "FAIL"


class TestLmmJaxValidation:
    """Tests validating JAX LMM runner against GEMMA reference.

    The JAX runner uses grid search + golden section optimization which
    may produce slightly different lambda values than Brent's method.
    Scientific equivalence (significance agreement, effect direction,
    SNP ranking) is the primary validation criterion.
    """

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_jax_scientific_equivalence(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner produces identical scientific conclusions (primary test).

        This is the most important validation: despite different optimization
        methods, the scientific conclusions must be identical.
        """
        from scipy.stats import spearmanr

        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jax_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            n_grid=50,
            n_refine=20,
            show_progress=False,
            check_memory=False,
        )

        # Build lookup by rs
        ref_by_rs = {r.rs: r for r in reference_results}
        jax_by_rs = {r.rs: r for r in jax_results}
        common_rs = set(ref_by_rs.keys()) & set(jax_by_rs.keys())

        ref_pvals = np.array([ref_by_rs[rs].p_wald for rs in common_rs])
        jax_pvals = np.array([jax_by_rs[rs].p_wald for rs in common_rs])

        # P-value rank correlation should be perfect
        rho, _ = spearmanr(-np.log10(jax_pvals), -np.log10(ref_pvals))
        assert rho > 0.9999, f"P-value rank correlation {rho:.6f} < 0.9999"

        # Significance agreement at standard thresholds
        for thresh in [0.05, 0.01, 0.001, 5e-8]:
            ref_sig = ref_pvals < thresh
            jax_sig = jax_pvals < thresh
            agreement = np.sum(ref_sig == jax_sig) / len(common_rs)
            assert agreement == 1.0, (
                f"Significance disagreement at p < {thresh:.0e}: "
                f"{(1 - agreement) * 100:.1f}% differ"
            )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_jax_vs_gemma_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner results match GEMMA within relaxed tolerances.

        JAX uses golden section optimization vs NumPy's Brent method, which
        can produce slightly different lambda values. This affects beta
        estimates due to the sensitivity of the optimization surface.

        We use relaxed tolerances here since the scientific equivalence
        (test_jax_scientific_equivalence) is the primary validation criterion.
        """
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jax_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            n_grid=50,
            n_refine=20,
            show_progress=False,
            check_memory=False,
        )

        # Use relaxed tolerances for JAX since golden section optimization
        # produces slightly different lambda values than Brent's method
        jax_tolerances = ToleranceConfig.relaxed()
        comparison = compare_assoc_results(
            jax_results, reference_results, config=jax_tolerances
        )

        # JAX should pass with relaxed tolerances
        assert comparison.passed, (
            f"JAX vs GEMMA comparison failed with relaxed tolerances:\n"
            f"  Beta: {comparison.beta.message}\n"
            f"  P-value: {comparison.p_wald.message}\n"
            f"  SE: {comparison.se.message}\n"
            f"  Lambda: {comparison.l_remle.message}"
        )

    def test_jax_accepts_covariates(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner accepts covariates and produces valid results."""
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)
        n_samples = len(phenotypes)

        # Create covariates: intercept + random covariate
        rng = np.random.default_rng(42)
        covariates = np.column_stack(
            [
                np.ones(n_samples),
                rng.standard_normal(n_samples),
            ]
        )

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            covariates=covariates,
            show_progress=False,
            check_memory=False,
        )

        # Should produce results
        assert len(results) > 0, "No results with covariates"

        # All results should be finite
        for r in results[:50]:
            assert np.isfinite(r.beta), f"NaN beta for {r.rs}"
            assert np.isfinite(r.se), f"NaN SE for {r.rs}"
            assert np.isfinite(r.p_wald), f"NaN p_wald for {r.rs}"
            assert 0 <= r.p_wald <= 1, f"p_wald out of range for {r.rs}"

    @pytest.mark.skipif(
        not COVARIATE_REFERENCE_ASSOC.exists(),
        reason="Covariate ref not generated. Run generate_covariate_reference.sh",
    )
    def test_jax_covariate_matches_gemma(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner with covariates matches GEMMA covariate reference."""
        if not COVARIATE_FILE.exists():
            pytest.skip("Covariate fixture not generated")

        covariates = np.loadtxt(COVARIATE_FILE)
        reference_results = load_gemma_assoc(COVARIATE_REFERENCE_ASSOC)

        jax_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariates,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jax_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    def test_jax_intercept_only_unchanged(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner with covariates=None matches explicit intercept column."""
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)
        n_samples = len(phenotypes)

        results_none = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            covariates=None,
            show_progress=False,
            check_memory=False,
        )

        results_intercept = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            covariates=np.ones((n_samples, 1)),
            show_progress=False,
            check_memory=False,
        )

        assert len(results_none) == len(results_intercept)

        for r_none, r_int in zip(results_none, results_intercept, strict=True):
            assert r_none.rs == r_int.rs
            np.testing.assert_allclose(
                r_none.beta,
                r_int.beta,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"Beta mismatch for {r_none.rs}",
            )
            np.testing.assert_allclose(
                r_none.p_wald,
                r_int.p_wald,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"P-value mismatch for {r_none.rs}",
            )


class TestJaxChunkingCorrectness:
    """Tests verifying multi-chunk JAX processing matches single-chunk.

    Chunking should be purely a memory/performance optimization that
    produces identical results regardless of chunk boundaries.
    """

    @pytest.fixture
    def chunk_test_data(self):
        """Generate data with enough SNPs to force multiple chunks at small scale."""
        rng = np.random.default_rng(42)
        n_samples = 200
        n_snps = 100  # Enough to test chunking at small chunk sizes

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_multi_chunk_equals_single_chunk(self, chunk_test_data):
        """Results are identical regardless of chunk size (multi vs single chunk).

        This tests the chunking implementation by forcing different chunk sizes
        and verifying the results match exactly.
        """
        from jamma.lmm import runner_jax

        genotypes, phenotypes, kinship, snp_info = chunk_test_data

        # Store original MAX_BUFFER_ELEMENTS
        original_max = runner_jax._MAX_BUFFER_ELEMENTS

        try:
            # Run with large buffer (single chunk - no chunking)
            runner_jax._MAX_BUFFER_ELEMENTS = 10**15  # Effectively no limit
            single_chunk_results = run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=kinship,
                snp_info=snp_info,
                check_memory=False,
                show_progress=False,
            )

            # Run with small buffer (force ~4 chunks with 200 samples x 100 SNPs)
            # Elements per SNP = 200 * 6 = 1200
            # With buffer = 30000, chunk_size = 30000 // 1200 = 25 SNPs
            runner_jax._MAX_BUFFER_ELEMENTS = 30_000
            multi_chunk_results = run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=kinship,
                snp_info=snp_info,
                check_memory=False,
                show_progress=False,
            )
        finally:
            # Restore original value
            runner_jax._MAX_BUFFER_ELEMENTS = original_max

        # Same number of results
        assert len(single_chunk_results) == len(multi_chunk_results)

        # Results should be numerically identical (not just close)
        for single, multi in zip(
            single_chunk_results, multi_chunk_results, strict=True
        ):
            assert (
                single.rs == multi.rs
            ), f"SNP order mismatch: {single.rs} vs {multi.rs}"
            np.testing.assert_allclose(
                single.beta,
                multi.beta,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"Beta mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.se,
                multi.se,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"SE mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.p_wald,
                multi.p_wald,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"P-value mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.l_remle,
                multi.l_remle,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"Lambda mismatch for {single.rs}",
            )


class TestLmmCovariateIntegration:
    """Tests for covariate integration in LMM association."""

    @pytest.fixture
    def covariate_test_data(self):
        """Generate test data for covariate tests."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_intercept_only_unchanged(self, covariate_test_data):
        """Intercept-only (covariates=None) matches explicit intercept column.

        This verifies that the default behavior (no covariates) is unchanged
        when explicitly providing an intercept-only covariate matrix.
        """
        genotypes, phenotypes, kinship, snp_info = covariate_test_data
        n_samples = len(phenotypes)

        # Run with covariates=None (default intercept-only)
        results_none = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=None,
            show_progress=False,
            check_memory=False,
        )

        # Run with explicit intercept column
        intercept_only = np.ones((n_samples, 1))
        results_explicit = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=intercept_only,
            show_progress=False,
            check_memory=False,
        )

        # Should have same number of results
        assert len(results_none) == len(results_explicit)

        # Results should be numerically identical
        for r_none, r_explicit in zip(results_none, results_explicit, strict=True):
            assert r_none.rs == r_explicit.rs
            np.testing.assert_allclose(
                r_none.beta,
                r_explicit.beta,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"Beta mismatch for {r_none.rs}",
            )
            np.testing.assert_allclose(
                r_none.se,
                r_explicit.se,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"SE mismatch for {r_none.rs}",
            )
            np.testing.assert_allclose(
                r_none.p_wald,
                r_explicit.p_wald,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"P-value mismatch for {r_none.rs}",
            )
            np.testing.assert_allclose(
                r_none.l_remle,
                r_explicit.l_remle,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"Lambda mismatch for {r_none.rs}",
            )

    def test_with_covariate_different_from_intercept_only(self, covariate_test_data):
        """Adding a non-trivial covariate changes results.

        This verifies that covariates actually affect the model. Without this
        test, a bug that ignores covariates would go undetected.
        """
        genotypes, phenotypes, kinship, snp_info = covariate_test_data
        n_samples = len(phenotypes)
        rng = np.random.default_rng(123)

        # Run with intercept only
        results_intercept = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=None,
            show_progress=False,
            check_memory=False,
        )

        # Run with intercept + a covariate correlated with phenotype
        # (to ensure it has a real effect on the model)
        covariate_col = phenotypes + rng.standard_normal(n_samples) * 0.5
        covariates_with_cov = np.column_stack(
            [
                np.ones(n_samples),  # Intercept
                covariate_col,  # Non-trivial covariate
            ]
        )
        results_with_cov = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=covariates_with_cov,
            show_progress=False,
            check_memory=False,
        )

        # Should have same number of results
        assert len(results_intercept) == len(results_with_cov)

        # At least some results should differ
        beta_diffs = [
            abs(r1.beta - r2.beta)
            for r1, r2 in zip(results_intercept, results_with_cov, strict=True)
        ]
        pval_diffs = [
            abs(r1.p_wald - r2.p_wald)
            for r1, r2 in zip(results_intercept, results_with_cov, strict=True)
        ]

        # Check that at least some betas and p-values differ
        assert max(beta_diffs) > 1e-6, "All betas identical - covariate unused"
        assert max(pval_diffs) > 1e-6, "All p-values identical - covariate unused"

    def test_missing_covariate_excluded(self, covariate_test_data):
        """Samples with missing covariate values are excluded from analysis."""
        genotypes, phenotypes, kinship, snp_info = covariate_test_data
        n_samples = len(phenotypes)

        # Create covariates with some missing values
        covariates = np.column_stack(
            [
                np.ones(n_samples),
                np.random.randn(n_samples),
            ]
        )
        # Set 5 samples to have missing covariates
        covariates[10:15, 1] = np.nan

        # Run should not error - missing samples excluded
        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=covariates,
            show_progress=False,
            check_memory=False,
        )

        # Should produce results (samples with missing covariates excluded)
        assert len(results) > 0
        # All results should have finite values
        for r in results:
            assert np.isfinite(r.beta), f"NaN beta for {r.rs}"
            assert np.isfinite(r.se), f"NaN SE for {r.rs}"
            assert np.isfinite(r.p_wald), f"NaN p-value for {r.rs}"


class TestLmmCovariateValidation:
    """Tests validating JAMMA LMM with covariates against GEMMA reference.

    These tests verify that JAMMA produces GEMMA-identical output when covariates
    are included in the model (beyond just the intercept).
    """

    @pytest.fixture
    def covariate_data(self):
        """Load covariates from fixture."""
        if not COVARIATE_FILE.exists():
            pytest.skip("Covariate fixture not generated")
        covariates = np.loadtxt(COVARIATE_FILE)
        return covariates

    @pytest.mark.skipif(
        not COVARIATE_REFERENCE_ASSOC.exists(),
        reason="Covariate ref not generated. Run generate_covariate_reference.sh",
    )
    def test_lmm_with_covariates_matches_gemma(
        self, mouse_data, mouse_phenotypes, reference_kinship, covariate_data
    ):
        """JAMMA LMM with covariates matches GEMMA reference within tolerance."""
        reference_results = load_gemma_assoc(COVARIATE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariate_data,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not COVARIATE_REFERENCE_ASSOC.exists(),
        reason="Covariate reference data not generated",
    )
    def test_covariate_beta_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship, covariate_data
    ):
        """Beta values with covariates match within tolerance."""
        reference_results = load_gemma_assoc(COVARIATE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariate_data,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert (
            comparison.beta.passed
        ), f"Beta with covariates failed: {comparison.beta.message}"

    @pytest.mark.skipif(
        not COVARIATE_REFERENCE_ASSOC.exists(),
        reason="Covariate reference data not generated",
    )
    def test_covariate_pvalue_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship, covariate_data
    ):
        """P-values with covariates match within tolerance."""
        reference_results = load_gemma_assoc(COVARIATE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariate_data,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert (
            comparison.p_wald.passed
        ), f"P-value with covariates failed: {comparison.p_wald.message}"


class TestAFSemantics:
    """Tests verifying allele frequency semantics and orientation behavior.

    These tests ensure:
    1. AF > 0.5 values pass through unchanged (no min transform to MAF)
    2. Flipping genotypes flips beta sign while preserving SE and p-value
    3. GEMMA fixture comparison uses direct AF match
    """

    def test_af_greater_than_half_not_transformed(self):
        """Verify that SNPs with af > 0.5 output af > 0.5 (no min transform)."""
        from jamma.lmm import _compute_snp_stats

        # Create genotype with high A1 frequency (~0.8)
        # Probabilities: 64% hom A1 (2), 32% het (1), 4% hom A2 (0)
        n_samples = 100
        rng = np.random.default_rng(42)
        genotypes = rng.choice(
            [0, 1, 2], size=(n_samples, 1), p=[0.04, 0.32, 0.64]
        ).astype(np.float64)

        # Compute expected AF
        expected_af = np.mean(genotypes[:, 0]) / 2.0
        assert (
            expected_af > 0.5
        ), f"Test setup error: expected AF > 0.5, got {expected_af}"

        # Run through _compute_snp_stats
        af, maf, _, _, _ = _compute_snp_stats(genotypes, 0)

        # AF should match expected (> 0.5)
        assert abs(af - expected_af) < 1e-10, f"AF mismatch: {af} vs {expected_af}"
        # MAF should be 1 - af (< 0.5)
        assert maf < 0.5, f"MAF should be < 0.5, got {maf}"
        assert abs(maf - (1.0 - af)) < 1e-10, "MAF should be 1-AF"

    def test_genotype_flip_inverts_beta_sign(self):
        """Verify that flipping genotypes (2-G) flips beta sign but not SE/p-value.

        This is a sanity check for allele orientation: when you flip the counted
        allele, the effect direction flips but the magnitude doesn't change.
        """
        rng = np.random.default_rng(42)
        n_samples = 150
        n_snps = 10

        # Generate genotypes with variation
        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)

        # Create phenotype with genetic component
        true_beta = rng.standard_normal(n_snps) * 0.5
        genetic_value = genotypes @ true_beta
        phenotypes = genetic_value + rng.standard_normal(n_samples)

        # Compute kinship for both orientations
        kinship_original = compute_centered_kinship(genotypes)

        # Flip genotypes: 2 - G (switches counted allele)
        genotypes_flipped = 2.0 - genotypes
        kinship_flipped = compute_centered_kinship(genotypes_flipped)

        # SNP info
        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        # Run LMM on both orientations
        results_original = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship_original,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )
        results_flipped = run_lmm_association_jax(
            genotypes=genotypes_flipped,
            phenotypes=phenotypes,
            kinship=kinship_flipped,
            snp_info=snp_info,
            show_progress=False,
            check_memory=False,
        )

        # Both should produce results for all SNPs
        assert len(results_original) == len(results_flipped)

        # For each SNP, beta should approximately flip sign
        # (kinship changes slightly affect exact values)
        for orig, flip in zip(results_original, results_flipped, strict=True):
            # Beta sign should flip (allow 10% tolerance for kinship effect)
            if abs(orig.beta) > 1e-6:  # Skip near-zero betas
                assert abs(orig.beta + flip.beta) < 0.2 * max(
                    abs(orig.beta), abs(flip.beta)
                ), f"Beta sign flip expected for {orig.rs}: {orig.beta} vs {flip.beta}"

            # SE should be very similar (doesn't depend on direction)
            if orig.se > 1e-8:
                se_ratio = flip.se / orig.se
                assert (
                    0.9 < se_ratio < 1.1
                ), f"SE should be similar for {orig.rs}: {orig.se} vs {flip.se}"

            # p-value should be very similar (Wald uses beta^2)
            if orig.p_wald < 0.99 and flip.p_wald < 0.99:  # Skip uninformative
                # Log scale comparison for p-values
                log_ratio = abs(np.log10(orig.p_wald) - np.log10(flip.p_wald))
                assert log_ratio < 0.5, (
                    f"p-value should be similar for {orig.rs}: "
                    f"{orig.p_wald} vs {flip.p_wald}"
                )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_gemma_fixture_has_af_above_half(self):
        """Confirm GEMMA fixture includes SNPs with AF > 0.5 for proper coverage.

        This test verifies that our reference data adequately tests the AF > 0.5
        case, ensuring the direct AF comparison (not MAF normalization) is
        actually being exercised.
        """
        gemma_results = load_gemma_assoc(REFERENCE_ASSOC)
        af_values = [r.af for r in gemma_results]

        # Check that we have SNPs above and below 0.5
        n_above = sum(1 for af in af_values if af > 0.5)
        n_below = sum(1 for af in af_values if af <= 0.5)

        assert n_above > 0, (
            f"GEMMA fixture should include SNPs with AF > 0.5 for coverage "
            f"(max AF: {max(af_values):.3f})"
        )
        assert n_below > 0, (
            f"GEMMA fixture should include SNPs with AF <= 0.5 for coverage "
            f"(min AF: {min(af_values):.3f})"
        )

    def test_af_output_in_lmm_results(self):
        """Verify that run_lmm_association_jax outputs raw AF (not MAF)."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 20

        # Create genotypes with some high-frequency alleles
        genotypes = np.zeros((n_samples, n_snps), dtype=np.float64)
        for i in range(n_snps):
            # Alternate between low and high frequency
            if i % 2 == 0:
                # Low frequency: mostly 0s, some 1s and 2s
                genotypes[:, i] = rng.choice(
                    [0, 1, 2], size=n_samples, p=[0.8, 0.15, 0.05]
                )
            else:
                # High frequency: mostly 2s, some 1s and 0s (AF > 0.5)
                genotypes[:, i] = rng.choice(
                    [0, 1, 2], size=n_samples, p=[0.05, 0.15, 0.8]
                )

        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)
        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            maf_threshold=0.01,  # Low threshold to keep high-AF SNPs
            show_progress=False,
            check_memory=False,
        )

        # Check that we have both AF > 0.5 and AF <= 0.5 in output
        af_values = [r.af for r in results]

        n_above_half = sum(1 for af in af_values if af > 0.5)
        n_at_or_below_half = sum(1 for af in af_values if af <= 0.5)

        # Expect roughly half above and half below due to our setup
        assert n_above_half > 0, (
            f"Expected some SNPs with AF > 0.5 in output, got none. "
            f"Max AF: {max(af_values):.3f}"
        )
        assert n_at_or_below_half > 0, (
            f"Expected some SNPs with AF <= 0.5 in output, got none. "
            f"Min AF: {min(af_values):.3f}"
        )


class TestLmmScoreValidation:
    """Tests validating JAMMA Score test against GEMMA reference.

    NOTE: These tests require GEMMA reference data which must be generated
    manually using scripts/generate_score_reference.sh. Tests are skipped
    in CI if reference data is not committed to the repository.
    """

    @pytest.mark.skipif(
        not _score_reference_exists(),
        reason=(
            "Score test reference not found. "
            "Run scripts/generate_score_reference.sh locally and commit the output."
        ),
    )
    def test_score_test_matches_gemma(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAMMA Score test matches GEMMA -lmm 3 within tolerance."""
        reference_results = load_gemma_assoc(SCORE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            lmm_mode=3,  # Score test
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not _score_reference_exists(),
        reason=(
            "Score test reference not found. "
            "Run scripts/generate_score_reference.sh locally and commit the output."
        ),
    )
    def test_score_pvalue_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """Score p-values match GEMMA within 1e-8 tolerance."""
        reference_results = load_gemma_assoc(SCORE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert comparison.p_score.passed, (
            f"Score p-value comparison failed: {comparison.p_score.message}\n"
            f"Max abs diff: {comparison.p_score.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_score.max_rel_diff:.2e}"
        )

    def test_score_has_no_per_snp_optimization(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """Score test uses fixed lambda (no per-SNP optimization).

        This test verifies the algorithmic difference between Score and Wald:
        - Wald: optimizes lambda independently for each SNP
        - Score: computes null model lambda once, reuses for all SNPs

        Rather than timing (which is noisy on small datasets where eigendecomp
        dominates), we verify that Score results use a single lambda value
        while Wald results have varying lambda per SNP.
        """
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        # Run Wald test
        wald_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            lmm_mode=1,  # Wald
            show_progress=False,
            check_memory=False,
        )

        # Run Score test
        score_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            lmm_mode=3,  # Score
            show_progress=False,
            check_memory=False,
        )

        # Wald should have varying l_remle values (per-SNP optimization)
        wald_lambdas = [r.l_remle for r in wald_results if r.l_remle is not None]
        assert (
            len(set(wald_lambdas)) > 1
        ), "Wald test should have varying lambda values per SNP"

        # Score should have no l_remle (uses fixed null model lambda)
        score_lambdas = [r.l_remle for r in score_results]
        assert all(
            lam is None for lam in score_lambdas
        ), "Score test should not have per-SNP l_remle values"

        # Score should have p_score, Wald should have p_wald
        assert all(
            r.p_score is not None for r in score_results
        ), "Score test results should have p_score"
        assert all(
            r.p_wald is not None for r in wald_results
        ), "Wald test results should have p_wald"


class TestScoreTestProperties:
    """Tests for Score test mathematical properties.

    These tests verify that the Score test implementation follows expected
    statistical properties, independent of GEMMA reference matching.
    """

    @pytest.fixture
    def score_test_data(self):
        """Generate test data for Score test properties."""
        rng = np.random.default_rng(42)
        n_samples = 150
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_score_uses_constant_lambda(self, score_test_data):
        """Score test uses same null model lambda for all SNPs.

        Unlike Wald test which optimizes lambda per-SNP, Score test
        computes lambda once under the null model.
        """
        genotypes, phenotypes, kinship, snp_info = score_test_data

        # Run Score test
        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )

        # All results should have l_remle=None (Score doesn't report per-SNP lambda)
        for r in results:
            assert r.l_remle is None, "Score test should not have per-SNP lambda"

    def test_score_pvalues_valid(self, score_test_data):
        """All Score p-values are in valid range [0, 1]."""
        genotypes, phenotypes, kinship, snp_info = score_test_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )

        for r in results:
            assert 0.0 <= r.p_score <= 1.0, f"Invalid p_score: {r.p_score}"

    def test_score_no_logl_per_snp(self, score_test_data):
        """Score test does not compute per-SNP log-likelihood."""
        genotypes, phenotypes, kinship, snp_info = score_test_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )

        for r in results:
            assert r.logl_H1 is None, "Score test should not have per-SNP logl_H1"
            assert r.p_wald is None, "Score test should not have p_wald"

    def test_score_produces_p_score(self, score_test_data):
        """Score test produces p_score field, not p_wald."""
        genotypes, phenotypes, kinship, snp_info = score_test_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )

        for r in results:
            assert r.p_score is not None, "Score test should produce p_score"
            assert r.p_wald is None, "Score test should not produce p_wald"


class TestLmmAllTestsValidation:
    """Tests validating JAMMA -lmm 4 (all tests) against GEMMA reference.

    These tests require GEMMA -lmm 4 reference data generated by
    scripts/generate_all_tests_reference.sh. Tests are skipped if
    reference data is not present.

    GEMMA -lmm 4 produces 14 columns (no logl_H1):
    chr rs ps n_miss allele1 allele0 af beta se l_remle l_mle p_wald p_lrt p_score

    JAMMA -lmm 4 produces 15 columns (includes logl_H1):
    chr rs ps n_miss allele1 allele0 af beta se
    logl_H1 l_remle l_mle p_wald p_lrt p_score
    """

    @pytest.mark.skipif(
        not _all_tests_reference_exists(),
        reason=(
            "All-tests reference not found. "
            "Run scripts/generate_all_tests_reference.sh locally."
        ),
    )
    def test_all_tests_matches_gemma(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAMMA -lmm 4 (intercept-only) matches GEMMA reference."""
        reference_results = load_gemma_assoc(ALL_TESTS_REFERENCE)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not ALL_TESTS_COVAR_REFERENCE.exists(),
        reason=(
            "All-tests covariate reference not found. "
            "Run scripts/generate_all_tests_reference.sh locally."
        ),
    )
    def test_all_tests_with_covariates_matches_gemma(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAMMA -lmm 4 with covariates matches GEMMA reference."""
        if not COVARIATE_FILE.exists():
            pytest.skip("Covariate fixture not generated")

        covariates = np.loadtxt(COVARIATE_FILE)
        reference_results = load_gemma_assoc(ALL_TESTS_COVAR_REFERENCE)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariates,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not _all_tests_reference_exists(),
        reason=(
            "All-tests reference not found. "
            "Run scripts/generate_all_tests_reference.sh locally."
        ),
    )
    def test_all_tests_column_tolerances(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """Per-column verification of -lmm 4 comparison results.

        Checks each column individually for detailed diagnostics.
        Note: logl_H1 comparison is skipped since GEMMA -lmm 4 does not
        output logl_H1 (14-column format vs JAMMA's 15-column format).
        """
        reference_results = load_gemma_assoc(ALL_TESTS_REFERENCE)

        jamma_results = run_lmm_association_jax(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(
            jamma_results, reference_results, config=JAX_GEMMA_TOLERANCES
        )

        # Verify each column individually for clear diagnostics
        assert comparison.beta.passed, (
            f"Beta comparison failed: {comparison.beta.message}\n"
            f"Max abs diff: {comparison.beta.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.beta.max_rel_diff:.2e}"
        )
        assert comparison.se.passed, (
            f"SE comparison failed: {comparison.se.message}\n"
            f"Max abs diff: {comparison.se.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.se.max_rel_diff:.2e}"
        )
        assert comparison.af.passed, f"AF comparison failed: {comparison.af.message}"
        assert comparison.p_wald.passed, (
            f"p_wald comparison failed: {comparison.p_wald.message}\n"
            f"Max abs diff: {comparison.p_wald.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_wald.max_rel_diff:.2e}"
        )
        # logl_H1 is skipped (GEMMA -lmm 4 has 14 columns, no logl_H1)
        assert (
            comparison.logl_H1.passed
        ), f"logl_H1 should be skipped/pass: {comparison.logl_H1.message}"
        assert (
            comparison.l_remle.passed
        ), f"l_remle comparison failed: {comparison.l_remle.message}"
        assert comparison.p_score.passed, (
            f"p_score comparison failed: {comparison.p_score.message}\n"
            f"Max abs diff: {comparison.p_score.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_score.max_rel_diff:.2e}"
        )
        assert comparison.p_lrt.passed, (
            f"p_lrt comparison failed: {comparison.p_lrt.message}\n"
            f"Max abs diff: {comparison.p_lrt.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_lrt.max_rel_diff:.2e}"
        )
        assert (
            comparison.l_mle.passed
        ), f"l_mle comparison failed: {comparison.l_mle.message}"


class TestLmmAllTestsProperties:
    """Tests for -lmm 4 (all tests) mathematical properties.

    These tests verify that mode 4 produces correct results using
    synthetic data, without relying on GEMMA reference fixtures.
    """

    @pytest.fixture
    def all_tests_data(self):
        """Generate synthetic data for all-tests property tests."""
        rng = np.random.default_rng(42)
        n_samples = 150
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_mode_4_produces_all_fields(self, all_tests_data):
        """Mode 4 populates all result fields."""
        genotypes, phenotypes, kinship, snp_info = all_tests_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        for r in results:
            assert r.logl_H1 is not None, f"logl_H1 is None for {r.rs}"
            assert r.l_remle is not None, f"l_remle is None for {r.rs}"
            assert r.l_mle is not None, f"l_mle is None for {r.rs}"
            assert r.p_wald is not None, f"p_wald is None for {r.rs}"
            assert r.p_lrt is not None, f"p_lrt is None for {r.rs}"
            assert r.p_score is not None, f"p_score is None for {r.rs}"
            assert np.isfinite(r.beta), f"beta is not finite for {r.rs}"
            assert np.isfinite(r.se), f"se is not finite for {r.rs}"

    def test_mode_4_pvalues_valid(self, all_tests_data):
        """All p-values from mode 4 are in [0, 1]."""
        genotypes, phenotypes, kinship, snp_info = all_tests_data

        results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        for r in results:
            assert 0.0 <= r.p_wald <= 1.0, f"Invalid p_wald: {r.p_wald} for {r.rs}"
            assert 0.0 <= r.p_lrt <= 1.0, f"Invalid p_lrt: {r.p_lrt} for {r.rs}"
            assert 0.0 <= r.p_score <= 1.0, f"Invalid p_score: {r.p_score} for {r.rs}"

    def test_mode_4_deterministic(self, all_tests_data):
        """Same input produces identical mode 4 output."""
        genotypes, phenotypes, kinship, snp_info = all_tests_data

        results1 = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )
        results2 = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        assert len(results1) == len(results2)
        for r1, r2 in zip(results1, results2, strict=True):
            assert r1.beta == r2.beta, f"beta mismatch for {r1.rs}"
            assert r1.se == r2.se, f"se mismatch for {r1.rs}"
            assert r1.p_wald == r2.p_wald, f"p_wald mismatch for {r1.rs}"
            assert r1.p_lrt == r2.p_lrt, f"p_lrt mismatch for {r1.rs}"
            assert r1.p_score == r2.p_score, f"p_score mismatch for {r1.rs}"

    def test_mode_4_beta_se_from_wald(self, all_tests_data):
        """Mode 4 beta/se matches standalone Wald (mode 1) exactly."""
        genotypes, phenotypes, kinship, snp_info = all_tests_data

        wald_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=1,
            show_progress=False,
            check_memory=False,
        )
        all_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        assert len(wald_results) == len(all_results)
        for wald, all_r in zip(wald_results, all_results, strict=True):
            assert wald.rs == all_r.rs, f"SNP order mismatch: {wald.rs} vs {all_r.rs}"
            assert (
                wald.beta == all_r.beta
            ), f"beta mismatch for {wald.rs}: {wald.beta} vs {all_r.beta}"
            assert (
                wald.se == all_r.se
            ), f"se mismatch for {wald.rs}: {wald.se} vs {all_r.se}"
            assert (
                wald.p_wald == all_r.p_wald
            ), f"p_wald mismatch for {wald.rs}: {wald.p_wald} vs {all_r.p_wald}"
            assert (
                wald.l_remle == all_r.l_remle
            ), f"l_remle mismatch for {wald.rs}: {wald.l_remle} vs {all_r.l_remle}"
            assert (
                wald.logl_H1 == all_r.logl_H1
            ), f"logl_H1 mismatch for {wald.rs}: {wald.logl_H1} vs {all_r.logl_H1}"

    def test_mode_4_p_score_matches_mode_3(self, all_tests_data):
        """Mode 4 p_score matches standalone Score test (mode 3) exactly."""
        genotypes, phenotypes, kinship, snp_info = all_tests_data

        score_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )
        all_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        assert len(score_results) == len(all_results)
        for score, all_r in zip(score_results, all_results, strict=True):
            assert score.rs == all_r.rs, f"SNP order mismatch: {score.rs} vs {all_r.rs}"
            assert (
                score.p_score == all_r.p_score
            ), f"p_score mismatch for {score.rs}: {score.p_score} vs {all_r.p_score}"

    def test_mode_4_p_lrt_matches_mode_2(self, all_tests_data):
        """Mode 4 p_lrt matches standalone LRT (mode 2) exactly."""
        genotypes, phenotypes, kinship, snp_info = all_tests_data

        lrt_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=2,
            show_progress=False,
            check_memory=False,
        )
        all_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        assert len(lrt_results) == len(all_results)
        for lrt, all_r in zip(lrt_results, all_results, strict=True):
            assert lrt.rs == all_r.rs, f"SNP order mismatch: {lrt.rs} vs {all_r.rs}"
            assert (
                lrt.p_lrt == all_r.p_lrt
            ), f"p_lrt mismatch for {lrt.rs}: {lrt.p_lrt} vs {all_r.p_lrt}"
            assert (
                lrt.l_mle == all_r.l_mle
            ), f"l_mle mismatch for {lrt.rs}: {lrt.l_mle} vs {all_r.l_mle}"


class TestMouseHS1940Validation:
    """Tests validating JAMMA against GEMMA on mouse_hs1940 dataset.

    This is the primary GEMMA validation dataset (1940 samples, 10768 SNPs).
    Tests cover all LMM modes (1-4) with and without covariates.
    """

    @pytest.mark.skipif(
        not MOUSE_HS1940_LRT.exists(),
        reason="mouse_hs1940 LRT fixture not found",
    )
    def test_mouse_hs1940_lrt_no_covar(
        self, hs1940_data, hs1940_phenotypes, hs1940_kinship
    ):
        """Mouse HS1940 LRT (mode 2, no covariates) matches GEMMA."""
        reference_results = load_gemma_assoc(MOUSE_HS1940_LRT)

        jamma_results = run_lmm_association_jax(
            genotypes=hs1940_data.genotypes,
            phenotypes=hs1940_phenotypes,
            kinship=hs1940_kinship,
            snp_info=_build_snp_info(hs1940_data),
            lmm_mode=2,
            show_progress=False,
            check_memory=False,
        )

        lrt_tolerances = ToleranceConfig(pvalue_rtol=5e-3)
        comparison = compare_assoc_results(
            jamma_results, reference_results, config=lrt_tolerances
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not MOUSE_HS1940_SCORE.exists(),
        reason="mouse_hs1940 Score fixture not found",
    )
    def test_mouse_hs1940_score_no_covar(
        self, hs1940_data, hs1940_phenotypes, hs1940_kinship
    ):
        """Mouse HS1940 Score test (mode 3, no covariates) matches GEMMA."""
        reference_results = load_gemma_assoc(MOUSE_HS1940_SCORE)

        jamma_results = run_lmm_association_jax(
            genotypes=hs1940_data.genotypes,
            phenotypes=hs1940_phenotypes,
            kinship=hs1940_kinship,
            snp_info=_build_snp_info(hs1940_data),
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not MOUSE_HS1940_ALL.exists(),
        reason="mouse_hs1940 all-tests fixture not found",
    )
    def test_mouse_hs1940_all_no_covar(
        self, hs1940_data, hs1940_phenotypes, hs1940_kinship
    ):
        """Mouse HS1940 all-tests (mode 4, no covariates) matches GEMMA."""
        reference_results = load_gemma_assoc(MOUSE_HS1940_ALL)

        jamma_results = run_lmm_association_jax(
            genotypes=hs1940_data.genotypes,
            phenotypes=hs1940_phenotypes,
            kinship=hs1940_kinship,
            snp_info=_build_snp_info(hs1940_data),
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        lrt_tolerances = ToleranceConfig(pvalue_rtol=5e-3)
        comparison = compare_assoc_results(
            jamma_results, reference_results, config=lrt_tolerances
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not MOUSE_HS1940_COVAR_WALD.exists(),
        reason="mouse_hs1940 covariate Wald fixture not found",
    )
    def test_mouse_hs1940_covar_wald(
        self, hs1940_data, hs1940_phenotypes, hs1940_kinship, hs1940_covariates
    ):
        """Mouse HS1940 Wald (mode 1, with covariates) matches GEMMA."""
        reference_results = load_gemma_assoc(MOUSE_HS1940_COVAR_WALD)

        jamma_results = run_lmm_association_jax(
            genotypes=hs1940_data.genotypes,
            phenotypes=hs1940_phenotypes,
            kinship=hs1940_kinship,
            snp_info=_build_snp_info(hs1940_data),
            covariates=hs1940_covariates,
            lmm_mode=1,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not MOUSE_HS1940_COVAR_LRT.exists(),
        reason="mouse_hs1940 covariate LRT fixture not found",
    )
    def test_mouse_hs1940_covar_lrt(
        self, hs1940_data, hs1940_phenotypes, hs1940_kinship, hs1940_covariates
    ):
        """Mouse HS1940 LRT (mode 2, with covariates) matches GEMMA."""
        reference_results = load_gemma_assoc(MOUSE_HS1940_COVAR_LRT)

        jamma_results = run_lmm_association_jax(
            genotypes=hs1940_data.genotypes,
            phenotypes=hs1940_phenotypes,
            kinship=hs1940_kinship,
            snp_info=_build_snp_info(hs1940_data),
            covariates=hs1940_covariates,
            lmm_mode=2,
            show_progress=False,
            check_memory=False,
        )

        lrt_tolerances = ToleranceConfig(pvalue_rtol=5e-3)
        comparison = compare_assoc_results(
            jamma_results, reference_results, config=lrt_tolerances
        )
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not MOUSE_HS1940_COVAR_SCORE.exists(),
        reason="mouse_hs1940 covariate Score fixture not found",
    )
    def test_mouse_hs1940_covar_score(
        self, hs1940_data, hs1940_phenotypes, hs1940_kinship, hs1940_covariates
    ):
        """Mouse HS1940 Score (mode 3, with covariates) matches GEMMA."""
        reference_results = load_gemma_assoc(MOUSE_HS1940_COVAR_SCORE)

        jamma_results = run_lmm_association_jax(
            genotypes=hs1940_data.genotypes,
            phenotypes=hs1940_phenotypes,
            kinship=hs1940_kinship,
            snp_info=_build_snp_info(hs1940_data),
            covariates=hs1940_covariates,
            lmm_mode=3,
            show_progress=False,
            check_memory=False,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not MOUSE_HS1940_COVAR_ALL.exists(),
        reason="mouse_hs1940 covariate all-tests fixture not found",
    )
    def test_mouse_hs1940_covar_all(
        self, hs1940_data, hs1940_phenotypes, hs1940_kinship, hs1940_covariates
    ):
        """Mouse HS1940 all-tests (mode 4, with covariates) matches GEMMA."""
        reference_results = load_gemma_assoc(MOUSE_HS1940_COVAR_ALL)

        jamma_results = run_lmm_association_jax(
            genotypes=hs1940_data.genotypes,
            phenotypes=hs1940_phenotypes,
            kinship=hs1940_kinship,
            snp_info=_build_snp_info(hs1940_data),
            covariates=hs1940_covariates,
            lmm_mode=4,
            show_progress=False,
            check_memory=False,
        )

        lrt_tolerances = ToleranceConfig(pvalue_rtol=5e-3)
        comparison = compare_assoc_results(
            jamma_results, reference_results, config=lrt_tolerances
        )
        assert comparison.passed, _format_comparison_failure(comparison)
