"""Validation tests for LMM association against GEMMA reference.

These tests verify JAMMA LMM produces numerically consistent results
that match reference GEMMA output within tolerance.

Note: These tests require reference data generated by GEMMA.
Run scripts/generate_lmm_reference.sh to generate fixtures.
"""

from pathlib import Path

import numpy as np
import pytest

from jamma.core import configure_jax
from jamma.io import load_plink_binary
from jamma.kinship import compute_centered_kinship
from jamma.kinship.io import read_kinship_matrix
from jamma.lmm import run_lmm_association
from jamma.lmm.io import write_assoc_results
from jamma.lmm.runner_jax import run_lmm_association_jax
from jamma.lmm.stats import AssocResult
from jamma.validation import (
    AssocComparisonResult,
    compare_assoc_results,
    load_gemma_assoc,
)

# Test data paths - use gemma_synthetic which has matching PLINK + reference outputs
EXAMPLE_DATA = Path("tests/fixtures/gemma_synthetic/test")
REFERENCE_KINSHIP = Path("tests/fixtures/gemma_synthetic/gemma_kinship.cXX.txt")
REFERENCE_ASSOC = Path("tests/fixtures/gemma_synthetic/gemma_assoc.assoc.txt")

# Covariate validation paths
COVARIATE_FIXTURE_DIR = Path("tests/fixtures/gemma_covariate")
COVARIATE_FILE = COVARIATE_FIXTURE_DIR / "covariates.txt"
COVARIATE_REFERENCE_ASSOC = COVARIATE_FIXTURE_DIR / "gemma_covariate.assoc.txt"

# Score test validation path
SCORE_REFERENCE_ASSOC = Path("tests/fixtures/gemma_score/gemma_score.assoc.txt")


def _score_reference_exists():
    """Check if Score test reference file exists."""
    return SCORE_REFERENCE_ASSOC.exists()


@pytest.fixture(autouse=True)
def setup_jax():
    """Configure JAX with 64-bit precision before each test."""
    configure_jax(enable_x64=True)


@pytest.fixture
def mouse_data():
    """Load gemma_synthetic PLINK data."""
    return load_plink_binary(EXAMPLE_DATA)


@pytest.fixture
def mouse_phenotypes():
    """Load phenotypes from PLINK .fam file (column 6)."""
    fam_path = EXAMPLE_DATA.with_suffix(".fam")
    phenotypes = []
    with open(fam_path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) >= 6:
                val = parts[5]
                if val == "-9" or val == "NA":
                    phenotypes.append(np.nan)
                else:
                    phenotypes.append(float(val))
    return np.array(phenotypes)


@pytest.fixture
def reference_kinship():
    """Load reference kinship matrix."""
    return read_kinship_matrix(REFERENCE_KINSHIP)


class TestLmmValidation:
    """Tests validating JAMMA LMM against GEMMA reference."""

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_matches_reference(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAMMA LMM matches GEMMA reference within tolerance."""
        # Load reference results
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        # Extract data from PLINK
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes

        # Build SNP info from PlinkData
        snp_info = _build_snp_info(mouse_data)

        # Run JAMMA LMM
        jamma_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
        )

        # Compare results
        comparison = compare_assoc_results(jamma_results, reference_results)

        # Assert overall pass
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_beta_tolerance(self, mouse_data, mouse_phenotypes, reference_kinship):
        """Effect sizes match within beta_rtol tolerance."""
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jamma_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)

        assert comparison.beta.passed, (
            f"Beta comparison failed: {comparison.beta.message}\n"
            f"Max abs diff: {comparison.beta.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.beta.max_rel_diff:.2e}"
        )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_pvalue_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """P-values match within pvalue_rtol tolerance."""
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jamma_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)

        assert comparison.p_wald.passed, (
            f"P-value comparison failed: {comparison.p_wald.message}\n"
            f"Max abs diff: {comparison.p_wald.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_wald.max_rel_diff:.2e}"
        )


class TestLmmOutputFormat:
    """Tests for LMM output format compatibility."""

    def test_assoc_output_roundtrip(self, tmp_path):
        """AssocResult can be written and read back."""
        results = [
            AssocResult(
                chr="1",
                rs="rs123",
                ps=12345,
                n_miss=0,
                allele1="A",
                allele0="G",
                af=0.25,
                beta=1.234567e-3,
                se=5.678901e-4,
                logl_H1=-1234.567890,
                l_remle=2.345678,
                p_wald=1.234567e-8,
            ),
            AssocResult(
                chr="2",
                rs="rs456",
                ps=67890,
                n_miss=5,
                allele1="T",
                allele0="C",
                af=0.123,
                beta=-2.345678e-2,
                se=1.234567e-3,
                logl_H1=-2345.678901,
                l_remle=0.987654,
                p_wald=5.678901e-5,
            ),
        ]

        # Write to file
        output_path = tmp_path / "test.assoc.txt"
        write_assoc_results(results, output_path)

        # Read back
        loaded = load_gemma_assoc(output_path)

        assert len(loaded) == len(results)
        for orig, loaded_result in zip(results, loaded, strict=True):
            assert orig.chr == loaded_result.chr
            assert orig.rs == loaded_result.rs
            assert orig.ps == loaded_result.ps
            assert orig.n_miss == loaded_result.n_miss
            assert orig.allele1 == loaded_result.allele1
            assert orig.allele0 == loaded_result.allele0
            # Numeric fields have some precision loss
            assert np.isclose(orig.af, loaded_result.af, rtol=1e-3)
            assert np.isclose(orig.beta, loaded_result.beta, rtol=1e-6)
            assert np.isclose(orig.se, loaded_result.se, rtol=1e-6)

    def test_assoc_output_header(self, tmp_path):
        """Output file has correct header."""
        results = [
            AssocResult(
                chr="1",
                rs="rs1",
                ps=1,
                n_miss=0,
                allele1="A",
                allele0="T",
                af=0.5,
                beta=0.0,
                se=0.1,
                logl_H1=-50.0,
                l_remle=1.0,
                p_wald=1.0,
            )
        ]

        output_path = tmp_path / "test.assoc.txt"
        write_assoc_results(results, output_path)

        with open(output_path) as f:
            header = f.readline().strip()

        expected = (
            "chr\trs\tps\tn_miss\tallele1\tallele0\t"
            "af\tbeta\tse\tlogl_H1\tl_remle\tp_wald"
        )
        assert header == expected


class TestLmmSmallScale:
    """Tests with smaller synthetic data for faster CI."""

    @pytest.fixture
    def small_data(self):
        """Small synthetic genetic data."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 50

        # Genotypes (0, 1, 2)
        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)

        # Phenotype with genetic component
        true_beta = rng.standard_normal(n_snps) * 0.1
        genetic_value = genotypes @ true_beta
        phenotypes = genetic_value + rng.standard_normal(n_samples)

        # Kinship matrix
        kinship = compute_centered_kinship(genotypes)

        # SNP info - use format expected by run_lmm_association
        snp_info = [
            {
                "chr": "1",
                "rs": f"rs{i}",
                "pos": i * 1000,
                "a1": "A",
                "a0": "G",
                "maf": 0.25,
                "n_miss": 0,
            }
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_small_lmm_runs(self, small_data):
        """LMM runs without errors on small data."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        assert len(results) == genotypes.shape[1]

    def test_small_lmm_valid_pvalues(self, small_data):
        """All p-values are in [0, 1]."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        for result in results:
            assert 0.0 <= result.p_wald <= 1.0, f"Invalid p-value: {result.p_wald}"

    def test_small_lmm_positive_se(self, small_data):
        """All standard errors are positive."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        for result in results:
            assert result.se > 0, f"Invalid SE: {result.se}"

    def test_small_lmm_deterministic(self, small_data):
        """Same input produces identical output."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results1 = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )
        results2 = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        for r1, r2 in zip(results1, results2, strict=True):
            assert r1.beta == r2.beta
            assert r1.se == r2.se
            assert r1.p_wald == r2.p_wald


class TestLmmWithMissingPhenotypes:
    """Tests for LMM with missing phenotype data."""

    @pytest.fixture
    def data_with_missing(self):
        """Data with missing phenotype values."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)

        # Set some phenotypes to missing (-9 or NaN)
        phenotypes[0:5] = -9.0
        phenotypes[10:15] = np.nan

        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {
                "chr": "1",
                "rs": f"rs{i}",
                "pos": i * 1000,
                "a1": "A",
                "a0": "G",
                "maf": 0.25,
                "n_miss": 0,
            }
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_missing_phenotypes_handled(self, data_with_missing):
        """LMM handles missing phenotypes without errors."""
        genotypes, phenotypes, kinship, snp_info = data_with_missing

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        # Should produce results for all SNPs
        assert len(results) == genotypes.shape[1]

        # No NaN values in output
        for result in results:
            assert np.isfinite(result.beta), f"NaN beta for {result.rs}"
            assert np.isfinite(result.se), f"NaN SE for {result.rs}"
            assert np.isfinite(result.p_wald), f"NaN p-value for {result.rs}"


def _build_snp_info(plink_data):
    """Build SNP info list from PLINK data."""
    snp_info = []
    for i in range(plink_data.n_snps):
        snp_info.append(
            {
                "chr": str(plink_data.chromosome[i]),
                "rs": plink_data.sid[i],
                "pos": plink_data.bp_position[i],
                "a1": plink_data.allele_1[i],
                "a0": plink_data.allele_2[i],
                "maf": 0.0,  # Will be computed during association
                "n_miss": 0,  # Will be computed during association
            }
        )
    return snp_info


def _format_comparison_failure(comparison: AssocComparisonResult) -> str:
    """Format detailed comparison failure message."""
    lines = [
        "\n=== LMM VALIDATION FAILURE ===",
        f"N SNPs: {comparison.n_snps}",
        f"Mismatched SNPs: {len(comparison.mismatched_snps)}",
        "",
        "Column comparisons:",
        f"  beta:    {_status(comparison.beta)} {comparison.beta.message}",
        f"  se:      {_status(comparison.se)} {comparison.se.message}",
        f"  p_wald:  {_status(comparison.p_wald)} {comparison.p_wald.message}",
        f"  logl_H1: {_status(comparison.logl_H1)} {comparison.logl_H1.message}",
        f"  l_remle: {_status(comparison.l_remle)} {comparison.l_remle.message}",
        f"  af:      {_status(comparison.af)} {comparison.af.message}",
    ]
    # Add p_score if present (Score test)
    if comparison.p_score is not None:
        lines.append(
            f"  p_score: {_status(comparison.p_score)} {comparison.p_score.message}"
        )
    lines.append("=============================")
    return "\n".join(lines)


def _status(result) -> str:
    """Return PASS or FAIL indicator."""
    return "PASS" if result.passed else "FAIL"


class TestLmmJaxValidation:
    """Tests validating JAX LMM runner against GEMMA reference.

    The JAX runner uses grid search + golden section optimization which
    may produce slightly different lambda values than Brent's method.
    Scientific equivalence (significance agreement, effect direction,
    SNP ranking) is the primary validation criterion.
    """

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_jax_scientific_equivalence(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner produces identical scientific conclusions (primary test).

        This is the most important validation: despite different optimization
        methods, the scientific conclusions must be identical.
        """
        from scipy.stats import spearmanr

        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jax_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            n_grid=50,
            n_refine=20,
        )

        # Build lookup by rs
        ref_by_rs = {r.rs: r for r in reference_results}
        jax_by_rs = {r.rs: r for r in jax_results}
        common_rs = set(ref_by_rs.keys()) & set(jax_by_rs.keys())

        ref_pvals = np.array([ref_by_rs[rs].p_wald for rs in common_rs])
        jax_pvals = np.array([jax_by_rs[rs].p_wald for rs in common_rs])

        # P-value rank correlation should be perfect
        rho, _ = spearmanr(-np.log10(jax_pvals), -np.log10(ref_pvals))
        assert rho > 0.9999, f"P-value rank correlation {rho:.6f} < 0.9999"

        # Significance agreement at standard thresholds
        for thresh in [0.05, 0.01, 0.001, 5e-8]:
            ref_sig = ref_pvals < thresh
            jax_sig = jax_pvals < thresh
            agreement = np.sum(ref_sig == jax_sig) / len(common_rs)
            assert agreement == 1.0, (
                f"Significance disagreement at p < {thresh:.0e}: "
                f"{(1-agreement)*100:.1f}% differ"
            )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_jax_vs_gemma_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner results match GEMMA within relaxed tolerances.

        JAX uses golden section optimization vs NumPy's Brent method, which
        can produce slightly different lambda values. This affects beta
        estimates due to the sensitivity of the optimization surface.

        We use relaxed tolerances here since the scientific equivalence
        (test_jax_scientific_equivalence) is the primary validation criterion.
        """
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jax_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            n_grid=50,
            n_refine=20,
        )

        # Use relaxed tolerances for JAX since golden section optimization
        # produces slightly different lambda values than Brent's method
        from jamma.validation import ToleranceConfig

        jax_tolerances = ToleranceConfig.relaxed()
        comparison = compare_assoc_results(
            jax_results, reference_results, config=jax_tolerances
        )

        # JAX should pass with relaxed tolerances
        assert comparison.passed, (
            f"JAX vs GEMMA comparison failed with relaxed tolerances:\n"
            f"  Beta: {comparison.beta.message}\n"
            f"  P-value: {comparison.p_wald.message}\n"
            f"  SE: {comparison.se.message}\n"
            f"  Lambda: {comparison.l_remle.message}"
        )

    def test_jax_rejects_covariates(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner raises NotImplementedError when covariates provided."""
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        # Create dummy covariates
        covariates = np.random.randn(len(phenotypes), 2)

        with pytest.raises(NotImplementedError, match="covariates"):
            run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=reference_kinship,
                snp_info=snp_info,
                covariates=covariates,
            )


class TestJaxChunkingCorrectness:
    """Tests verifying multi-chunk JAX processing matches single-chunk.

    Chunking should be purely a memory/performance optimization that
    produces identical results regardless of chunk boundaries.
    """

    @pytest.fixture
    def chunk_test_data(self):
        """Generate data with enough SNPs to force multiple chunks at small scale."""
        rng = np.random.default_rng(42)
        n_samples = 200
        n_snps = 100  # Enough to test chunking at small chunk sizes

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_multi_chunk_equals_single_chunk(self, chunk_test_data):
        """Results are identical regardless of chunk size (multi vs single chunk).

        This tests the chunking implementation by forcing different chunk sizes
        and verifying the results match exactly.
        """
        from jamma.lmm import runner_jax

        genotypes, phenotypes, kinship, snp_info = chunk_test_data

        # Store original MAX_BUFFER_ELEMENTS
        original_max = runner_jax._MAX_BUFFER_ELEMENTS

        try:
            # Run with large buffer (single chunk - no chunking)
            runner_jax._MAX_BUFFER_ELEMENTS = 10**15  # Effectively no limit
            single_chunk_results = run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=kinship,
                snp_info=snp_info,
                check_memory=False,
            )

            # Run with small buffer (force ~4 chunks with 200 samples Ã— 100 SNPs)
            # Elements per SNP = 200 * 6 = 1200
            # With buffer = 30000, chunk_size = 30000 // 1200 = 25 SNPs
            runner_jax._MAX_BUFFER_ELEMENTS = 30_000
            multi_chunk_results = run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=kinship,
                snp_info=snp_info,
                check_memory=False,
            )
        finally:
            # Restore original value
            runner_jax._MAX_BUFFER_ELEMENTS = original_max

        # Same number of results
        assert len(single_chunk_results) == len(multi_chunk_results)

        # Results should be numerically identical (not just close)
        for single, multi in zip(
            single_chunk_results, multi_chunk_results, strict=True
        ):
            assert (
                single.rs == multi.rs
            ), f"SNP order mismatch: {single.rs} vs {multi.rs}"
            np.testing.assert_allclose(
                single.beta,
                multi.beta,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"Beta mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.se,
                multi.se,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"SE mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.p_wald,
                multi.p_wald,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"P-value mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.l_remle,
                multi.l_remle,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"Lambda mismatch for {single.rs}",
            )


class TestLmmCovariateIntegration:
    """Tests for covariate integration in LMM association."""

    @pytest.fixture
    def covariate_test_data(self):
        """Generate test data for covariate tests."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_intercept_only_unchanged(self, covariate_test_data):
        """Intercept-only (covariates=None) matches explicit intercept column.

        This verifies that the default behavior (no covariates) is unchanged
        when explicitly providing an intercept-only covariate matrix.
        """
        genotypes, phenotypes, kinship, snp_info = covariate_test_data
        n_samples = len(phenotypes)

        # Run with covariates=None (default intercept-only)
        results_none = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=None,
        )

        # Run with explicit intercept column
        intercept_only = np.ones((n_samples, 1))
        results_explicit = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=intercept_only,
        )

        # Should have same number of results
        assert len(results_none) == len(results_explicit)

        # Results should be numerically identical
        for r_none, r_explicit in zip(results_none, results_explicit, strict=True):
            assert r_none.rs == r_explicit.rs
            np.testing.assert_allclose(
                r_none.beta,
                r_explicit.beta,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"Beta mismatch for {r_none.rs}",
            )
            np.testing.assert_allclose(
                r_none.se,
                r_explicit.se,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"SE mismatch for {r_none.rs}",
            )
            np.testing.assert_allclose(
                r_none.p_wald,
                r_explicit.p_wald,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"P-value mismatch for {r_none.rs}",
            )
            np.testing.assert_allclose(
                r_none.l_remle,
                r_explicit.l_remle,
                rtol=1e-10,
                atol=1e-14,
                err_msg=f"Lambda mismatch for {r_none.rs}",
            )

    def test_with_covariate_different_from_intercept_only(self, covariate_test_data):
        """Adding a non-trivial covariate changes results.

        This verifies that covariates actually affect the model. Without this
        test, a bug that ignores covariates would go undetected.
        """
        genotypes, phenotypes, kinship, snp_info = covariate_test_data
        n_samples = len(phenotypes)
        rng = np.random.default_rng(123)

        # Run with intercept only
        results_intercept = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=None,
        )

        # Run with intercept + a covariate correlated with phenotype
        # (to ensure it has a real effect on the model)
        covariate_col = phenotypes + rng.standard_normal(n_samples) * 0.5
        covariates_with_cov = np.column_stack(
            [
                np.ones(n_samples),  # Intercept
                covariate_col,  # Non-trivial covariate
            ]
        )
        results_with_cov = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=covariates_with_cov,
        )

        # Should have same number of results
        assert len(results_intercept) == len(results_with_cov)

        # At least some results should differ
        beta_diffs = [
            abs(r1.beta - r2.beta)
            for r1, r2 in zip(results_intercept, results_with_cov, strict=True)
        ]
        pval_diffs = [
            abs(r1.p_wald - r2.p_wald)
            for r1, r2 in zip(results_intercept, results_with_cov, strict=True)
        ]

        # Check that at least some betas and p-values differ
        assert max(beta_diffs) > 1e-6, "All betas identical - covariate unused"
        assert max(pval_diffs) > 1e-6, "All p-values identical - covariate unused"

    def test_missing_covariate_excluded(self, covariate_test_data):
        """Samples with missing covariate values are excluded from analysis."""
        genotypes, phenotypes, kinship, snp_info = covariate_test_data
        n_samples = len(phenotypes)

        # Create covariates with some missing values
        covariates = np.column_stack(
            [
                np.ones(n_samples),
                np.random.randn(n_samples),
            ]
        )
        # Set 5 samples to have missing covariates
        covariates[10:15, 1] = np.nan

        # Run should not error - missing samples excluded
        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            covariates=covariates,
        )

        # Should produce results (samples with missing covariates excluded)
        assert len(results) > 0
        # All results should have finite values
        for r in results:
            assert np.isfinite(r.beta), f"NaN beta for {r.rs}"
            assert np.isfinite(r.se), f"NaN SE for {r.rs}"
            assert np.isfinite(r.p_wald), f"NaN p-value for {r.rs}"


class TestLmmCovariateValidation:
    """Tests validating JAMMA LMM with covariates against GEMMA reference.

    These tests verify that JAMMA produces GEMMA-identical output when covariates
    are included in the model (beyond just the intercept).
    """

    @pytest.fixture
    def covariate_data(self):
        """Load covariates from fixture."""
        if not COVARIATE_FILE.exists():
            pytest.skip("Covariate fixture not generated")
        covariates = np.loadtxt(COVARIATE_FILE)
        return covariates

    @pytest.mark.skipif(
        not COVARIATE_REFERENCE_ASSOC.exists(),
        reason="Covariate ref not generated. Run generate_covariate_reference.sh",
    )
    def test_lmm_with_covariates_matches_gemma(
        self, mouse_data, mouse_phenotypes, reference_kinship, covariate_data
    ):
        """JAMMA LMM with covariates matches GEMMA reference within tolerance."""
        reference_results = load_gemma_assoc(COVARIATE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariate_data,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not COVARIATE_REFERENCE_ASSOC.exists(),
        reason="Covariate reference data not generated",
    )
    def test_covariate_beta_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship, covariate_data
    ):
        """Beta values with covariates match within tolerance."""
        reference_results = load_gemma_assoc(COVARIATE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariate_data,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert (
            comparison.beta.passed
        ), f"Beta with covariates failed: {comparison.beta.message}"

    @pytest.mark.skipif(
        not COVARIATE_REFERENCE_ASSOC.exists(),
        reason="Covariate reference data not generated",
    )
    def test_covariate_pvalue_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship, covariate_data
    ):
        """P-values with covariates match within tolerance."""
        reference_results = load_gemma_assoc(COVARIATE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            covariates=covariate_data,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert (
            comparison.p_wald.passed
        ), f"P-value with covariates failed: {comparison.p_wald.message}"


class TestAFSemantics:
    """Tests verifying allele frequency semantics and orientation behavior.

    These tests ensure:
    1. AF > 0.5 values pass through unchanged (no min transform to MAF)
    2. Flipping genotypes flips beta sign while preserving SE and p-value
    3. GEMMA fixture comparison uses direct AF match
    """

    def test_af_greater_than_half_not_transformed(self):
        """Verify that SNPs with af > 0.5 output af > 0.5 (no min transform)."""
        from jamma.lmm import _compute_snp_stats

        # Create genotype with high A1 frequency (~0.8)
        # Probabilities: 64% hom A1 (2), 32% het (1), 4% hom A2 (0)
        n_samples = 100
        rng = np.random.default_rng(42)
        genotypes = rng.choice(
            [0, 1, 2], size=(n_samples, 1), p=[0.04, 0.32, 0.64]
        ).astype(np.float64)

        # Compute expected AF
        expected_af = np.mean(genotypes[:, 0]) / 2.0
        assert (
            expected_af > 0.5
        ), f"Test setup error: expected AF > 0.5, got {expected_af}"

        # Run through _compute_snp_stats
        af, maf, _, _, _ = _compute_snp_stats(genotypes, 0)

        # AF should match expected (> 0.5)
        assert abs(af - expected_af) < 1e-10, f"AF mismatch: {af} vs {expected_af}"
        # MAF should be 1 - af (< 0.5)
        assert maf < 0.5, f"MAF should be < 0.5, got {maf}"
        assert abs(maf - (1.0 - af)) < 1e-10, "MAF should be 1-AF"

    def test_genotype_flip_inverts_beta_sign(self):
        """Verify that flipping genotypes (2-G) flips beta sign but not SE/p-value.

        This is a sanity check for allele orientation: when you flip the counted
        allele, the effect direction flips but the magnitude doesn't change.
        """
        rng = np.random.default_rng(42)
        n_samples = 150
        n_snps = 10

        # Generate genotypes with variation
        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)

        # Create phenotype with genetic component
        true_beta = rng.standard_normal(n_snps) * 0.5
        genetic_value = genotypes @ true_beta
        phenotypes = genetic_value + rng.standard_normal(n_samples)

        # Compute kinship for both orientations
        kinship_original = compute_centered_kinship(genotypes)

        # Flip genotypes: 2 - G (switches counted allele)
        genotypes_flipped = 2.0 - genotypes
        kinship_flipped = compute_centered_kinship(genotypes_flipped)

        # SNP info
        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        # Run LMM on both orientations
        results_original = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship_original,
            snp_info=snp_info,
        )
        results_flipped = run_lmm_association(
            genotypes=genotypes_flipped,
            phenotypes=phenotypes,
            kinship=kinship_flipped,
            snp_info=snp_info,
        )

        # Both should produce results for all SNPs
        assert len(results_original) == len(results_flipped)

        # For each SNP, beta should approximately flip sign
        # (kinship changes slightly affect exact values)
        for orig, flip in zip(results_original, results_flipped, strict=True):
            # Beta sign should flip (allow 10% tolerance for kinship effect)
            if abs(orig.beta) > 1e-6:  # Skip near-zero betas
                assert abs(orig.beta + flip.beta) < 0.2 * max(
                    abs(orig.beta), abs(flip.beta)
                ), f"Beta sign flip expected for {orig.rs}: {orig.beta} vs {flip.beta}"

            # SE should be very similar (doesn't depend on direction)
            if orig.se > 1e-8:
                se_ratio = flip.se / orig.se
                assert (
                    0.9 < se_ratio < 1.1
                ), f"SE should be similar for {orig.rs}: {orig.se} vs {flip.se}"

            # p-value should be very similar (Wald uses beta^2)
            if orig.p_wald < 0.99 and flip.p_wald < 0.99:  # Skip uninformative
                # Log scale comparison for p-values
                log_ratio = abs(np.log10(orig.p_wald) - np.log10(flip.p_wald))
                assert log_ratio < 0.5, (
                    f"p-value should be similar for {orig.rs}: "
                    f"{orig.p_wald} vs {flip.p_wald}"
                )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_gemma_fixture_has_af_above_half(self):
        """Confirm GEMMA fixture includes SNPs with AF > 0.5 for proper coverage.

        This test verifies that our reference data adequately tests the AF > 0.5
        case, ensuring the direct AF comparison (not MAF normalization) is
        actually being exercised.
        """
        gemma_results = load_gemma_assoc(REFERENCE_ASSOC)
        af_values = [r.af for r in gemma_results]

        # Check that we have SNPs above and below 0.5
        n_above = sum(1 for af in af_values if af > 0.5)
        n_below = sum(1 for af in af_values if af <= 0.5)

        assert n_above > 0, (
            f"GEMMA fixture should include SNPs with AF > 0.5 for coverage "
            f"(max AF: {max(af_values):.3f})"
        )
        assert n_below > 0, (
            f"GEMMA fixture should include SNPs with AF <= 0.5 for coverage "
            f"(min AF: {min(af_values):.3f})"
        )

    def test_af_output_in_lmm_results(self):
        """Verify that run_lmm_association outputs raw AF (not MAF)."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 20

        # Create genotypes with some high-frequency alleles
        genotypes = np.zeros((n_samples, n_snps), dtype=np.float64)
        for i in range(n_snps):
            # Alternate between low and high frequency
            if i % 2 == 0:
                # Low frequency: mostly 0s, some 1s and 2s
                genotypes[:, i] = rng.choice(
                    [0, 1, 2], size=n_samples, p=[0.8, 0.15, 0.05]
                )
            else:
                # High frequency: mostly 2s, some 1s and 0s (AF > 0.5)
                genotypes[:, i] = rng.choice(
                    [0, 1, 2], size=n_samples, p=[0.05, 0.15, 0.8]
                )

        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)
        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            maf_threshold=0.01,  # Low threshold to keep high-AF SNPs
        )

        # Check that we have both AF > 0.5 and AF <= 0.5 in output
        af_values = [r.af for r in results]

        n_above_half = sum(1 for af in af_values if af > 0.5)
        n_at_or_below_half = sum(1 for af in af_values if af <= 0.5)

        # Expect roughly half above and half below due to our setup
        assert n_above_half > 0, (
            f"Expected some SNPs with AF > 0.5 in output, got none. "
            f"Max AF: {max(af_values):.3f}"
        )
        assert n_at_or_below_half > 0, (
            f"Expected some SNPs with AF <= 0.5 in output, got none. "
            f"Min AF: {min(af_values):.3f}"
        )


class TestLmmScoreValidation:
    """Tests validating JAMMA Score test against GEMMA reference.

    NOTE: These tests require GEMMA reference data which must be generated
    manually using scripts/generate_score_reference.sh. Tests are skipped
    in CI if reference data is not committed to the repository.

    KNOWN ISSUE: JAMMA's null model lambda computation differs from GEMMA's,
    resulting in different p_score values. GEMMA uses a specific pve estimation
    method (CalcPVEnull in param.cpp) that produces lambda values different from
    standard REML optimization. This requires further investigation to match
    GEMMA's exact algorithm. The Score test formula itself is correct, but the
    input lambda affects all downstream statistics.
    """

    @pytest.mark.xfail(
        reason=(
            "JAMMA null model lambda differs from GEMMA. "
            "GEMMA uses CalcPVEnull method that produces different lambda values "
            "than standard REML optimization. Requires investigation of GEMMA's "
            "exact pve estimation algorithm."
        ),
        strict=False,  # Allow unexpected passes during investigation
    )
    @pytest.mark.skipif(
        not _score_reference_exists(),
        reason=(
            "Score test reference not found. "
            "Run scripts/generate_score_reference.sh locally and commit the output."
        ),
    )
    def test_score_test_matches_gemma(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAMMA Score test matches GEMMA -lmm 3 within tolerance."""
        reference_results = load_gemma_assoc(SCORE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            lmm_mode=3,  # Score test
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.xfail(
        reason=(
            "JAMMA null model lambda differs from GEMMA. "
            "See test_score_test_matches_gemma docstring for details."
        ),
        strict=False,
    )
    @pytest.mark.skipif(
        not _score_reference_exists(),
        reason=(
            "Score test reference not found. "
            "Run scripts/generate_score_reference.sh locally and commit the output."
        ),
    )
    def test_score_pvalue_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """Score p-values match GEMMA within 1e-8 tolerance."""
        reference_results = load_gemma_assoc(SCORE_REFERENCE_ASSOC)

        jamma_results = run_lmm_association(
            genotypes=mouse_data.genotypes,
            phenotypes=mouse_phenotypes,
            kinship=reference_kinship,
            snp_info=_build_snp_info(mouse_data),
            lmm_mode=3,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)
        assert comparison.p_score.passed, (
            f"Score p-value comparison failed: {comparison.p_score.message}\n"
            f"Max abs diff: {comparison.p_score.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_score.max_rel_diff:.2e}"
        )

    def test_score_has_no_per_snp_optimization(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """Score test uses fixed lambda (no per-SNP optimization).

        This test verifies the algorithmic difference between Score and Wald:
        - Wald: optimizes lambda independently for each SNP
        - Score: computes null model lambda once, reuses for all SNPs

        Rather than timing (which is noisy on small datasets where eigendecomp
        dominates), we verify that Score results use a single lambda value
        while Wald results have varying lambda per SNP.
        """
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        # Run Wald test
        wald_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            lmm_mode=1,  # Wald
        )

        # Run Score test
        score_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            lmm_mode=3,  # Score
        )

        # Wald should have varying l_remle values (per-SNP optimization)
        wald_lambdas = [r.l_remle for r in wald_results if r.l_remle is not None]
        assert (
            len(set(wald_lambdas)) > 1
        ), "Wald test should have varying lambda values per SNP"

        # Score should have no l_remle (uses fixed null model lambda)
        score_lambdas = [r.l_remle for r in score_results]
        assert all(
            lam is None for lam in score_lambdas
        ), "Score test should not have per-SNP l_remle values"

        # Score should have p_score, Wald should have p_wald
        assert all(
            r.p_score is not None for r in score_results
        ), "Score test results should have p_score"
        assert all(
            r.p_wald is not None for r in wald_results
        ), "Wald test results should have p_wald"


class TestScoreTestProperties:
    """Tests for Score test mathematical properties.

    These tests verify that the Score test implementation follows expected
    statistical properties, independent of GEMMA reference matching.
    """

    @pytest.fixture
    def score_test_data(self):
        """Generate test data for Score test properties."""
        rng = np.random.default_rng(42)
        n_samples = 150
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_score_uses_constant_lambda(self, score_test_data):
        """Score test uses same null model lambda for all SNPs.

        Unlike Wald test which optimizes lambda per-SNP, Score test
        computes lambda once under the null model.
        """
        genotypes, phenotypes, kinship, snp_info = score_test_data

        # Run Score test
        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
        )

        # All results should have l_remle=None (Score doesn't report per-SNP lambda)
        for r in results:
            assert r.l_remle is None, "Score test should not have per-SNP lambda"

    def test_score_pvalues_valid(self, score_test_data):
        """All Score p-values are in valid range [0, 1]."""
        genotypes, phenotypes, kinship, snp_info = score_test_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
        )

        for r in results:
            assert 0.0 <= r.p_score <= 1.0, f"Invalid p_score: {r.p_score}"

    def test_score_no_logl_per_snp(self, score_test_data):
        """Score test does not compute per-SNP log-likelihood."""
        genotypes, phenotypes, kinship, snp_info = score_test_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
        )

        for r in results:
            assert r.logl_H1 is None, "Score test should not have per-SNP logl_H1"
            assert r.p_wald is None, "Score test should not have p_wald"

    def test_score_produces_p_score(self, score_test_data):
        """Score test produces p_score field, not p_wald."""
        genotypes, phenotypes, kinship, snp_info = score_test_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
            lmm_mode=3,
        )

        for r in results:
            assert r.p_score is not None, "Score test should produce p_score"
            assert r.p_wald is None, "Score test should not produce p_wald"
