"""Validation tests for LMM association against GEMMA reference.

These tests verify JAMMA LMM produces numerically consistent results
that match reference GEMMA output within tolerance.

Note: These tests require reference data generated by GEMMA.
Run scripts/generate_lmm_reference.sh to generate fixtures.
"""

from pathlib import Path

import numpy as np
import pytest

from jamma.core import configure_jax
from jamma.io import load_plink_binary
from jamma.kinship import compute_centered_kinship
from jamma.kinship.io import read_kinship_matrix
from jamma.lmm import run_lmm_association
from jamma.lmm.io import write_assoc_results
from jamma.lmm.runner_jax import run_lmm_association_jax
from jamma.lmm.stats import AssocResult
from jamma.validation import (
    AssocComparisonResult,
    compare_assoc_results,
    load_gemma_assoc,
)

# Test data paths - use gemma_synthetic which has matching PLINK + reference outputs
EXAMPLE_DATA = Path("tests/fixtures/gemma_synthetic/test")
REFERENCE_KINSHIP = Path("tests/fixtures/gemma_synthetic/gemma_kinship.cXX.txt")
REFERENCE_ASSOC = Path("tests/fixtures/gemma_synthetic/gemma_assoc.assoc.txt")


@pytest.fixture(autouse=True)
def setup_jax():
    """Configure JAX with 64-bit precision before each test."""
    configure_jax(enable_x64=True)


@pytest.fixture
def mouse_data():
    """Load gemma_synthetic PLINK data."""
    return load_plink_binary(EXAMPLE_DATA)


@pytest.fixture
def mouse_phenotypes():
    """Load phenotypes from PLINK .fam file (column 6)."""
    fam_path = EXAMPLE_DATA.with_suffix(".fam")
    phenotypes = []
    with open(fam_path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) >= 6:
                val = parts[5]
                if val == "-9" or val == "NA":
                    phenotypes.append(np.nan)
                else:
                    phenotypes.append(float(val))
    return np.array(phenotypes)


@pytest.fixture
def reference_kinship():
    """Load reference kinship matrix."""
    return read_kinship_matrix(REFERENCE_KINSHIP)


class TestLmmValidation:
    """Tests validating JAMMA LMM against GEMMA reference."""

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_matches_reference(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAMMA LMM matches GEMMA reference within tolerance."""
        # Load reference results
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        # Extract data from PLINK
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes

        # Build SNP info from PlinkData
        snp_info = _build_snp_info(mouse_data)

        # Run JAMMA LMM
        jamma_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
        )

        # Compare results
        comparison = compare_assoc_results(jamma_results, reference_results)

        # Assert overall pass
        assert comparison.passed, _format_comparison_failure(comparison)

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_beta_tolerance(self, mouse_data, mouse_phenotypes, reference_kinship):
        """Effect sizes match within beta_rtol tolerance."""
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jamma_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)

        assert comparison.beta.passed, (
            f"Beta comparison failed: {comparison.beta.message}\n"
            f"Max abs diff: {comparison.beta.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.beta.max_rel_diff:.2e}"
        )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_lmm_pvalue_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """P-values match within pvalue_rtol tolerance."""
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jamma_results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
        )

        comparison = compare_assoc_results(jamma_results, reference_results)

        assert comparison.p_wald.passed, (
            f"P-value comparison failed: {comparison.p_wald.message}\n"
            f"Max abs diff: {comparison.p_wald.max_abs_diff:.2e}\n"
            f"Max rel diff: {comparison.p_wald.max_rel_diff:.2e}"
        )


class TestLmmOutputFormat:
    """Tests for LMM output format compatibility."""

    def test_assoc_output_roundtrip(self, tmp_path):
        """AssocResult can be written and read back."""
        results = [
            AssocResult(
                chr="1",
                rs="rs123",
                ps=12345,
                n_miss=0,
                allele1="A",
                allele0="G",
                af=0.25,
                beta=1.234567e-3,
                se=5.678901e-4,
                logl_H1=-1234.567890,
                l_remle=2.345678,
                p_wald=1.234567e-8,
            ),
            AssocResult(
                chr="2",
                rs="rs456",
                ps=67890,
                n_miss=5,
                allele1="T",
                allele0="C",
                af=0.123,
                beta=-2.345678e-2,
                se=1.234567e-3,
                logl_H1=-2345.678901,
                l_remle=0.987654,
                p_wald=5.678901e-5,
            ),
        ]

        # Write to file
        output_path = tmp_path / "test.assoc.txt"
        write_assoc_results(results, output_path)

        # Read back
        loaded = load_gemma_assoc(output_path)

        assert len(loaded) == len(results)
        for orig, loaded_result in zip(results, loaded, strict=True):
            assert orig.chr == loaded_result.chr
            assert orig.rs == loaded_result.rs
            assert orig.ps == loaded_result.ps
            assert orig.n_miss == loaded_result.n_miss
            assert orig.allele1 == loaded_result.allele1
            assert orig.allele0 == loaded_result.allele0
            # Numeric fields have some precision loss
            assert np.isclose(orig.af, loaded_result.af, rtol=1e-3)
            assert np.isclose(orig.beta, loaded_result.beta, rtol=1e-6)
            assert np.isclose(orig.se, loaded_result.se, rtol=1e-6)

    def test_assoc_output_header(self, tmp_path):
        """Output file has correct header."""
        results = [
            AssocResult(
                chr="1",
                rs="rs1",
                ps=1,
                n_miss=0,
                allele1="A",
                allele0="T",
                af=0.5,
                beta=0.0,
                se=0.1,
                logl_H1=-50.0,
                l_remle=1.0,
                p_wald=1.0,
            )
        ]

        output_path = tmp_path / "test.assoc.txt"
        write_assoc_results(results, output_path)

        with open(output_path) as f:
            header = f.readline().strip()

        expected = (
            "chr\trs\tps\tn_miss\tallele1\tallele0\t"
            "af\tbeta\tse\tlogl_H1\tl_remle\tp_wald"
        )
        assert header == expected


class TestLmmSmallScale:
    """Tests with smaller synthetic data for faster CI."""

    @pytest.fixture
    def small_data(self):
        """Small synthetic genetic data."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 50

        # Genotypes (0, 1, 2)
        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)

        # Phenotype with genetic component
        true_beta = rng.standard_normal(n_snps) * 0.1
        genetic_value = genotypes @ true_beta
        phenotypes = genetic_value + rng.standard_normal(n_samples)

        # Kinship matrix
        kinship = compute_centered_kinship(genotypes)

        # SNP info - use format expected by run_lmm_association
        snp_info = [
            {
                "chr": "1",
                "rs": f"rs{i}",
                "pos": i * 1000,
                "a1": "A",
                "a0": "G",
                "maf": 0.25,
                "n_miss": 0,
            }
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_small_lmm_runs(self, small_data):
        """LMM runs without errors on small data."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        assert len(results) == genotypes.shape[1]

    def test_small_lmm_valid_pvalues(self, small_data):
        """All p-values are in [0, 1]."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        for result in results:
            assert 0.0 <= result.p_wald <= 1.0, f"Invalid p-value: {result.p_wald}"

    def test_small_lmm_positive_se(self, small_data):
        """All standard errors are positive."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        for result in results:
            assert result.se > 0, f"Invalid SE: {result.se}"

    def test_small_lmm_deterministic(self, small_data):
        """Same input produces identical output."""
        genotypes, phenotypes, kinship, snp_info = small_data

        results1 = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )
        results2 = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        for r1, r2 in zip(results1, results2, strict=True):
            assert r1.beta == r2.beta
            assert r1.se == r2.se
            assert r1.p_wald == r2.p_wald


class TestLmmWithMissingPhenotypes:
    """Tests for LMM with missing phenotype data."""

    @pytest.fixture
    def data_with_missing(self):
        """Data with missing phenotype values."""
        rng = np.random.default_rng(42)
        n_samples = 100
        n_snps = 30

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)

        # Set some phenotypes to missing (-9 or NaN)
        phenotypes[0:5] = -9.0
        phenotypes[10:15] = np.nan

        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {
                "chr": "1",
                "rs": f"rs{i}",
                "pos": i * 1000,
                "a1": "A",
                "a0": "G",
                "maf": 0.25,
                "n_miss": 0,
            }
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_missing_phenotypes_handled(self, data_with_missing):
        """LMM handles missing phenotypes without errors."""
        genotypes, phenotypes, kinship, snp_info = data_with_missing

        results = run_lmm_association(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=kinship,
            snp_info=snp_info,
        )

        # Should produce results for all SNPs
        assert len(results) == genotypes.shape[1]

        # No NaN values in output
        for result in results:
            assert np.isfinite(result.beta), f"NaN beta for {result.rs}"
            assert np.isfinite(result.se), f"NaN SE for {result.rs}"
            assert np.isfinite(result.p_wald), f"NaN p-value for {result.rs}"


def _build_snp_info(plink_data):
    """Build SNP info list from PLINK data."""
    snp_info = []
    for i in range(plink_data.n_snps):
        snp_info.append(
            {
                "chr": str(plink_data.chromosome[i]),
                "rs": plink_data.sid[i],
                "pos": plink_data.bp_position[i],
                "a1": plink_data.allele_1[i],
                "a0": plink_data.allele_2[i],
                "maf": 0.0,  # Will be computed during association
                "n_miss": 0,  # Will be computed during association
            }
        )
    return snp_info


def _format_comparison_failure(comparison: AssocComparisonResult) -> str:
    """Format detailed comparison failure message."""
    lines = [
        "\n=== LMM VALIDATION FAILURE ===",
        f"N SNPs: {comparison.n_snps}",
        f"Mismatched SNPs: {len(comparison.mismatched_snps)}",
        "",
        "Column comparisons:",
        f"  beta:    {_status(comparison.beta)} {comparison.beta.message}",
        f"  se:      {_status(comparison.se)} {comparison.se.message}",
        f"  p_wald:  {_status(comparison.p_wald)} {comparison.p_wald.message}",
        f"  logl_H1: {_status(comparison.logl_H1)} {comparison.logl_H1.message}",
        f"  l_remle: {_status(comparison.l_remle)} {comparison.l_remle.message}",
        f"  af:      {_status(comparison.af)} {comparison.af.message}",
        "=============================",
    ]
    return "\n".join(lines)


def _status(result) -> str:
    """Return PASS or FAIL indicator."""
    return "PASS" if result.passed else "FAIL"


class TestLmmJaxValidation:
    """Tests validating JAX LMM runner against GEMMA reference.

    The JAX runner uses grid search + golden section optimization which
    may produce slightly different lambda values than Brent's method.
    Scientific equivalence (significance agreement, effect direction,
    SNP ranking) is the primary validation criterion.
    """

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_jax_scientific_equivalence(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner produces identical scientific conclusions (primary test).

        This is the most important validation: despite different optimization
        methods, the scientific conclusions must be identical.
        """
        from scipy.stats import spearmanr

        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jax_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            n_grid=50,
            n_refine=20,
        )

        # Build lookup by rs
        ref_by_rs = {r.rs: r for r in reference_results}
        jax_by_rs = {r.rs: r for r in jax_results}
        common_rs = set(ref_by_rs.keys()) & set(jax_by_rs.keys())

        ref_pvals = np.array([ref_by_rs[rs].p_wald for rs in common_rs])
        jax_pvals = np.array([jax_by_rs[rs].p_wald for rs in common_rs])

        # P-value rank correlation should be perfect
        rho, _ = spearmanr(-np.log10(jax_pvals), -np.log10(ref_pvals))
        assert rho > 0.9999, f"P-value rank correlation {rho:.6f} < 0.9999"

        # Significance agreement at standard thresholds
        for thresh in [0.05, 0.01, 0.001, 5e-8]:
            ref_sig = ref_pvals < thresh
            jax_sig = jax_pvals < thresh
            agreement = np.sum(ref_sig == jax_sig) / len(common_rs)
            assert agreement == 1.0, (
                f"Significance disagreement at p < {thresh:.0e}: "
                f"{(1-agreement)*100:.1f}% differ"
            )

    @pytest.mark.skipif(
        not REFERENCE_ASSOC.exists(),
        reason="Reference LMM data not generated. Run generate_lmm_reference.sh",
    )
    def test_jax_vs_gemma_tolerance(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner results match GEMMA within relaxed tolerances.

        JAX uses golden section optimization vs NumPy's Brent method, which
        can produce slightly different lambda values. This affects beta
        estimates due to the sensitivity of the optimization surface.

        We use relaxed tolerances here since the scientific equivalence
        (test_jax_scientific_equivalence) is the primary validation criterion.
        """
        reference_results = load_gemma_assoc(REFERENCE_ASSOC)

        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        jax_results = run_lmm_association_jax(
            genotypes=genotypes,
            phenotypes=phenotypes,
            kinship=reference_kinship,
            snp_info=snp_info,
            n_grid=50,
            n_refine=20,
        )

        # Use relaxed tolerances for JAX since golden section optimization
        # produces slightly different lambda values than Brent's method
        from jamma.validation import ToleranceConfig

        jax_tolerances = ToleranceConfig.relaxed()
        comparison = compare_assoc_results(
            jax_results, reference_results, config=jax_tolerances
        )

        # JAX should pass with relaxed tolerances
        assert comparison.passed, (
            f"JAX vs GEMMA comparison failed with relaxed tolerances:\n"
            f"  Beta: {comparison.beta.message}\n"
            f"  P-value: {comparison.p_wald.message}\n"
            f"  SE: {comparison.se.message}\n"
            f"  Lambda: {comparison.l_remle.message}"
        )

    def test_jax_rejects_covariates(
        self, mouse_data, mouse_phenotypes, reference_kinship
    ):
        """JAX runner raises NotImplementedError when covariates provided."""
        genotypes = mouse_data.genotypes
        phenotypes = mouse_phenotypes
        snp_info = _build_snp_info(mouse_data)

        # Create dummy covariates
        covariates = np.random.randn(len(phenotypes), 2)

        with pytest.raises(NotImplementedError, match="covariates"):
            run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=reference_kinship,
                snp_info=snp_info,
                covariates=covariates,
            )


class TestJaxChunkingCorrectness:
    """Tests verifying multi-chunk JAX processing matches single-chunk.

    Chunking should be purely a memory/performance optimization that
    produces identical results regardless of chunk boundaries.
    """

    @pytest.fixture
    def chunk_test_data(self):
        """Generate data with enough SNPs to force multiple chunks at small scale."""
        rng = np.random.default_rng(42)
        n_samples = 200
        n_snps = 100  # Enough to test chunking at small chunk sizes

        genotypes = rng.integers(0, 3, size=(n_samples, n_snps)).astype(np.float64)
        phenotypes = rng.standard_normal(n_samples)
        kinship = compute_centered_kinship(genotypes)

        snp_info = [
            {"chr": "1", "rs": f"rs{i}", "pos": i * 1000, "a1": "A", "a0": "G"}
            for i in range(n_snps)
        ]

        return genotypes, phenotypes, kinship, snp_info

    def test_multi_chunk_equals_single_chunk(self, chunk_test_data):
        """Results are identical regardless of chunk size (multi vs single chunk).

        This tests the chunking implementation by forcing different chunk sizes
        and verifying the results match exactly.
        """
        from jamma.lmm import runner_jax

        genotypes, phenotypes, kinship, snp_info = chunk_test_data

        # Store original MAX_BUFFER_ELEMENTS
        original_max = runner_jax._MAX_BUFFER_ELEMENTS

        try:
            # Run with large buffer (single chunk - no chunking)
            runner_jax._MAX_BUFFER_ELEMENTS = 10**15  # Effectively no limit
            single_chunk_results = run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=kinship,
                snp_info=snp_info,
                check_memory=False,
            )

            # Run with small buffer (force ~4 chunks with 200 samples Ã— 100 SNPs)
            # Elements per SNP = 200 * 6 = 1200
            # With buffer = 30000, chunk_size = 30000 // 1200 = 25 SNPs
            runner_jax._MAX_BUFFER_ELEMENTS = 30_000
            multi_chunk_results = run_lmm_association_jax(
                genotypes=genotypes,
                phenotypes=phenotypes,
                kinship=kinship,
                snp_info=snp_info,
                check_memory=False,
            )
        finally:
            # Restore original value
            runner_jax._MAX_BUFFER_ELEMENTS = original_max

        # Same number of results
        assert len(single_chunk_results) == len(multi_chunk_results)

        # Results should be numerically identical (not just close)
        for single, multi in zip(
            single_chunk_results, multi_chunk_results, strict=True
        ):
            assert (
                single.rs == multi.rs
            ), f"SNP order mismatch: {single.rs} vs {multi.rs}"
            np.testing.assert_allclose(
                single.beta,
                multi.beta,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"Beta mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.se,
                multi.se,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"SE mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.p_wald,
                multi.p_wald,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"P-value mismatch for {single.rs}",
            )
            np.testing.assert_allclose(
                single.l_remle,
                multi.l_remle,
                rtol=1e-10,
                atol=1e-15,
                err_msg=f"Lambda mismatch for {single.rs}",
            )
